<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automobile Data Dashboard | Portfolio Edition</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- D3.js for 2D Charting -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Three.js for 3D Charting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Light Theme (kept for toggle functionality, but default is dark) */
            --bg-primary: #f9fafb;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f3f4f6;
            --bg-inset: #e5e7eb;
            --border-color: #e5e7eb;
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --text-tertiary: #6b7280;
            --accent-primary: #ca8a04; /* gold-600 */
            --accent-gradient: linear-gradient(to right, #facc15, #eab308);
            --shadow-color: 224 71% 4% / 0.1;
        }
        /* --- Black and Gold Theme --- */
        html.dark {
            --bg-primary: #0a0a0a; /* near black */
            --bg-secondary: #1a1a1a; /* darker gray */
            --bg-tertiary: #2a2a2a; /* dark gray */
            --bg-inset: #111827;
            --border-color: #3a3a3a; /* lighter gray for borders */
            --text-primary: #f9fafb; /* off-white */
            --text-secondary: #a3a3a3; /* light gray */
            --text-tertiary: #737373; /* medium gray */
            --accent-primary: #facc15; /* gold-400 */
            --accent-gradient: linear-gradient(to right, #fde047, #facc15);
            --shadow-color: 220 90% 4% / 0.2;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-secondary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #4b5563; }

        .chart-tooltip {
            position: absolute;
            text-align: left;
            padding: 0.75rem;
            font-size: 0.875rem;
            background: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            border-radius: 12px;
            pointer-events: none;
            opacity: 0;
            color: var(--text-primary);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 9999;
            white-space: nowrap;
        }
        .chart-container {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 1rem; /* 16px */
            padding: 1.5rem; /* 24px */
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px var(--shadow-color), 0 2px 4px -2px var(--shadow-color);
        }
        .axis path, .axis line { stroke: var(--border-color); }
        .axis text { fill: var(--text-secondary); font-size: 12px; }
        .grid-lines line { stroke: var(--border-color); stroke-opacity: 0.7; stroke-dasharray: 4,4; }
        .grid-lines path { stroke-width: 0; }
        
        .three-canvas-container { width: 100%; height: 100%; position: relative; border-radius: 0.75rem; overflow: hidden;}
        .three-canvas-container canvas { display: block; }
        
        .label-3d {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            background: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
            padding: 4px 8px;
            border-radius: 6px;
        }
        .sidebar-transition { transition: transform 0.3s ease-in-out; }
    </style>
</head>
<body class="antialiased">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        // --- FIXED DATA URL ---
        const DATA_URL = 'public/Rawdata/Automobile_data.csv';

        // --- DATA LOADING & PROCESSING HOOK ---
        const useAutomobileData = () => {
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            const cleanRow = useCallback((d) => {
                const newRow = {};
                for (const key in d) {
                    const newKey = key.trim().replace(/-/g, '_');
                    const val = d[key].trim();
                    if (val === '?' || val === '') {
                        newRow[newKey] = null;
                    } else {
                        const numVal = +val;
                        newRow[newKey] = isNaN(numVal) ? val : numVal;
                    }
                }
                if (!newRow.price || !newRow.horsepower || !newRow.curb_weight || !newRow.make || !newRow.body_style) {
                    return null;
                }
                return newRow;
            }, []);

            useEffect(() => {
                d3.csv(DATA_URL)
                    .then(raw => {
                        const cleanedData = raw.map(cleanRow).filter(Boolean);
                        setData(cleanedData);
                    })
                    .catch(err => {
                        console.error("Error loading or parsing data:", err);
                        setError("Failed to load dataset. Please check the console for details.");
                    })
                    .finally(() => setLoading(false));
            }, [cleanRow]);
            
            const numericCols = useMemo(() => ['price', 'horsepower', 'curb_weight', 'engine_size', 'city_mpg', 'highway_mpg', 'wheel_base', 'length', 'width', 'height', 'bore', 'stroke', 'compression_ratio', 'peak_rpm', 'symboling', 'normalized_losses'], []);
            const categoricalCols = useMemo(() => ['make', 'body_style', 'fuel_type', 'aspiration', 'num_of_doors', 'drive_wheels', 'engine_location', 'engine_type', 'num_of_cylinders', 'fuel_system'], []);

            return { data, loading, error, numericCols, categoricalCols };
        };
        
        // --- UI & HELPER COMPONENTS ---
        const Tooltip = React.forwardRef((props, ref) => <div ref={ref} className="chart-tooltip"></div>);

        const Icon = ({ path, className = "w-6 h-6", strokeWidth = 1.5 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={strokeWidth} strokeLinecap="round" strokeLinejoin="round" className={className}>
                {path}
            </svg>
        );

        // --- NEW Black & Gold Theme Icons (FIXED) ---
        const ICONS = {
            'Line Chart': <Icon path={<><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline></>} />,
            'Scatter Plot': <Icon path={<><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="5" r="1"></circle><circle cx="5" cy="19" r="1"></circle><circle cx="5" cy="5" r="1"></circle><circle cx="19" cy="19" r="1"></circle></>} />,
            'Box Plot': <Icon path={<><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></>} />,
            'Heatmap': <Icon path={<><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line></>} />,
            '3D Scatter': <Icon path={<><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><path d="m3.27 6.96 8.74 5.05 8.74-5.05"></path><path d="m12 22.08 V 12"></path></>} />,
            'Menu': <Icon path={<><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></>} />,
            'Close': <Icon path={<><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>} />,
            'Sun': <Icon path={<><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></>} className="w-5 h-5" />,
            'Moon': <Icon path={<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>} className="w-5 h-5" fill="currentColor"/>,
            'Car': <Icon path={<><path d="M14 16.5V15a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v1.5"></path><path d="M20 10h-2.34a2 2 0 0 0-1.97 1.66l-1.39 5.57a2 2 0 0 1-1.97 1.66H9.67a2 2 0 0 1-1.97-1.66L6.31 11.66A2 2 0 0 0 4.34 10H2"></path><path d="M17.5 10.5c.36.14.7.4.95.74.25.34.4.76.4 1.21v3.05"></path><path d="M6.5 10.5c-.36.14-.7.4-.95.74-.25.34-.4.76-.4 1.21v3.05"></path><circle cx="6" cy="19" r="2"></circle><circle cx="18" cy="19" r="2"></circle></>} />,
            'Dollar': <Icon path={<><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></>} />,
            'Trophy': <Icon path={<><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path><path d="M4 22h16"></path><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path></>} />,
            'Zap': <Icon path={<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>} />,
        };

        const KpiCard = ({ title, value, icon, format }) => (
            <div className="bg-bg-secondary p-5 rounded-xl border border-border-color flex items-center space-x-4 transition-all duration-300 hover:shadow-lg hover:-translate-y-1">
                <div className="p-3 rounded-lg bg-accent-primary/10 text-accent-primary">
                    {icon}
                </div>
                <div>
                    <p className="text-sm text-text-secondary font-medium">{title}</p>
                    <p className="text-2xl font-bold text-text-primary">{format ? format(value) : value}</p>
                </div>
            </div>
        );
        
        const ControlSelect = ({ label, value, onChange, options, disabled=false }) => (
            <div>
                <label className="block text-sm font-medium text-text-secondary mb-1.5 capitalize">{label.replace(/_/g, ' ')}</label>
                <select 
                    value={value} 
                    onChange={onChange} 
                    disabled={disabled} 
                    className="w-full p-2.5 bg-bg-primary text-text-primary border border-border-color rounded-lg shadow-sm focus:ring-2 focus:ring-accent-primary focus:border-accent-primary disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                >
                    {options.map(opt => <option key={opt} value={opt} className="bg-bg-secondary text-text-primary">{opt.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</option>)}
                </select>
            </div>
        );

        const ControlToggle = ({ label, checked, onChange, disabled=false }) => (
            <div className="flex items-center justify-between pt-2">
                <span className="text-sm font-medium text-text-secondary">{label}</span>
                <label className="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" checked={checked} onChange={onChange} disabled={disabled} className="sr-only peer" />
                    <div className="w-11 h-6 bg-bg-tertiary rounded-full peer peer-focus:ring-2 peer-focus:ring-offset-2 peer-focus:ring-offset-bg-secondary peer-focus:ring-accent-primary/50 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-accent-primary"></div>
                </label>
            </div>
        );
        
        // --- D3 CHARTING LOGIC (REUSABLE) ---
        const D3Chart = ({ draw, dependencies, className }) => {
            const svgRef = useRef();
            const tooltipRef = useRef();

            useEffect(() => {
                const svg = d3.select(svgRef.current);
                const tooltip = d3.select(tooltipRef.current);
                
                if (!svg.node()) return;

                let resizeTimer;
                const handleResize = () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => {
                        if (svg.node()) draw(svg, tooltip);
                    }, 150);
                };
                
                draw(svg, tooltip);

                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [draw, ...dependencies]);

            return (
                <div className={`relative w-full h-full ${className || ''}`}>
                    <svg ref={svgRef} className="w-full h-full" />
                    <Tooltip ref={tooltipRef} />
                </div>
            );
        };

        // --- CHART COMPONENTS ---
        const ChartComponents = {
            LineChart: ({ data, x, y, hue, error: errorStyle }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 150, bottom: 60, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;
                    
                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                    const xScale = d3.scaleLinear().domain(d3.extent(data, d => d[x])).range([0, width]).nice();
                    const yScale = d3.scaleLinear().domain(d3.extent(data, d => d[y])).range([height, 0]).nice();
                    const groupedData = hue !== 'None' ? d3.group(data, d => d[hue]) : [['all', data]];
                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(Array.from(groupedData.keys()));

                    g.append("g").attr("class", "grid-lines").call(d3.axisLeft(yScale).ticks(5).tickSize(-width).tickFormat(""));
                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale).ticks(Math.min(10, width/80))).append("text").attr("y", 45).attr("x", width/2).attr("fill", "currentColor").attr("text-anchor", "middle").attr("font-size", "14px").text(x.replace(/_/g, ' '));
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale)).append("text").attr("transform", "rotate(-90)").attr("y", -50).attr("x", -height/2).attr("fill", "currentColor").attr("text-anchor", "middle").attr("font-size", "14px").text(y.replace(/_/g, ' '));
                    
                    groupedData.forEach((groupData, key) => {
                        const sortedGroup = groupData.sort((a,b) => a[x] - b[x]);
                        const aggregatedData = Array.from(d3.group(sortedGroup, d => d[x]), ([xVal, yVals]) => {
                            const mean = d3.mean(yVals, d => d[y]);
                            const std = d3.deviation(yVals, d => d[y]);
                            return { x: xVal, y: mean, y0: mean - std, y1: mean + std };
                        }).filter(d => d.y !== undefined);

                        if(errorStyle === 'band' && aggregatedData.length > 1){
                            g.append("path").datum(aggregatedData).attr("fill", colorScale(key)).attr("opacity", 0.2).attr("d", d3.area().x(d => xScale(d.x)).y0(d => yScale(d.y0)).y1(d => yScale(d.y1)));
                        }
                        g.append("path").datum(aggregatedData).attr("fill", "none").attr("stroke", colorScale(key)).attr("stroke-width", 2.5).attr("d", d3.line().x(d => xScale(d.x)).y(d => yScale(d.y)));
                    });

                    if (hue !== 'None') {
                        const legend = g.selectAll(".legend").data(colorScale.domain()).enter().append("g")
                            .attr("class", "legend").attr("transform", (d, i) => `translate(${width + 30},${i * 25})`);
                        legend.append("rect").attr("x", 0).attr("width", 18).attr("height", 18).attr("rx", 4).style("fill", colorScale);
                        legend.append("text").attr("x", 24).attr("y", 9).attr("dy", ".35em").style("text-anchor", "start").text(d => d).attr("fill", "var(--text-secondary)");
                    }
                }, [data, x, y, hue, errorStyle]);
                return <D3Chart draw={draw} dependencies={[data, x, y, hue, errorStyle]} />;
            },
            ScatterPlot: ({ data, x, y, hue, size }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 150, bottom: 60, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;
                    
                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                    const xScale = d3.scaleLinear().domain(d3.extent(data, d => d[x])).range([0, width]).nice();
                    const yScale = d3.scaleLinear().domain(d3.extent(data, d => d[y])).range([height, 0]).nice();
                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(hue !== 'None' ? [...new Set(data.map(d => d[hue]))].sort() : ['all']);
                    const sizeScale = d3.scaleLinear().domain(size !== 'None' ? d3.extent(data, d => d[size]) : [1,1]).range([4, 15]);

                    g.append("g").attr("class", "grid-lines").call(d3.axisLeft(yScale).ticks(5).tickSize(-width).tickFormat(""));
                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale).ticks(Math.min(10, width/80))).append("text").attr("y", 45).attr("x", width/2).attr("fill", "currentColor").attr("text-anchor", "middle").attr("font-size", "14px").text(x.replace(/_/g, ' '));
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale)).append("text").attr("transform", "rotate(-90)").attr("y", -50).attr("x", -height/2).attr("fill", "currentColor").attr("text-anchor", "middle").attr("font-size", "14px").text(y.replace(/_/g, ' '));

                    g.selectAll("circle").data(data).join("circle")
                        .attr("cx", d => xScale(d[x])).attr("cy", d => yScale(d[y]))
                        .attr("r", d => sizeScale(size !== 'None' ? d[size] : 1))
                        .attr("fill", d => colorScale(hue !== 'None' ? d[hue] : 'var(--accent-primary)'))
                        .attr("opacity", 0.7).attr("stroke", "var(--bg-secondary)").attr("stroke-width", 1.5)
                        .on("mouseover", (event, d) => {
                            tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`);
                            tooltip.html(`<strong class="text-base" style="color: var(--text-primary);">${d.make}</strong><br><span class="capitalize">${x.replace(/_/g, ' ')}</span>: ${d[x]}<br><span class="capitalize">${y.replace(/_/g, ' ')}</span>: ${d[y]}${hue !== 'None' ? `<br><span class="capitalize">${hue.replace(/_/g, ' ')}</span>: ${d[hue]}` : ''}${size !== 'None' ? `<br><span class="capitalize">${size.replace(/_/g, ' ')}</span>: ${d[size]}` : ''}`);
                        })
                        .on("mouseout", () => tooltip.style("opacity", 0));
                    
                    if (hue !== 'None') {
                        const legend = g.selectAll(".legend").data(colorScale.domain()).enter().append("g")
                            .attr("class", "legend").attr("transform", (d, i) => `translate(${width + 30},${i * 25})`);
                        legend.append("rect").attr("x", 0).attr("width", 18).attr("height", 18).attr("rx", 4).style("fill", colorScale);
                        legend.append("text").attr("x", 24).attr("y", 9).attr("dy", ".35em").style("text-anchor", "start").text(d => d).attr("fill", "var(--text-secondary)");
                    }
                }, [data, x, y, hue, size]);
                return <D3Chart draw={draw} dependencies={[data, x, y, hue, size]} />;
            },
            BoxPlot: ({ data, x, y, notch }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 30, bottom: 100, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;
                    
                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                    const groupedData = d3.group(data, d => d[x]);
                    const summaryStats = [];
                    groupedData.forEach((groupData, key) => {
                        const sortedValues = groupData.map(d => d[y]).filter(v => v != null).sort(d3.ascending);
                        if(sortedValues.length === 0) return;
                        const q1 = d3.quantile(sortedValues, 0.25);
                        const median = d3.quantile(sortedValues, 0.5);
                        const q3 = d3.quantile(sortedValues, 0.75);
                        if ([q1, median, q3].some(v => v === undefined)) return;
                        const iqr = q3 - q1;
                        const min = Math.max(d3.min(sortedValues), q1 - 1.5 * iqr);
                        const max = Math.min(d3.max(sortedValues), q3 + 1.5 * iqr);
                        summaryStats.push({ key, q1, median, q3, min, max });
                    });
                    summaryStats.sort((a,b) => d3.ascending(a.key, b.key));

                    const xScale = d3.scaleBand().domain(summaryStats.map(d => d.key)).range([0, width]).padding(0.4);
                    const yScale = d3.scaleLinear().domain([0, d3.max(data, d => d[y])]).range([height, 0]).nice();
                    
                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale))
                        .selectAll("text").attr("transform", "rotate(-45)").style("text-anchor", "end");
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale));
                    g.append("g").attr("class", "grid-lines").call(d3.axisLeft(yScale).ticks(5).tickSize(-width).tickFormat(""));

                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(summaryStats.map(d => d.key));

                    summaryStats.forEach(d => {
                        const boxG = g.append("g").attr("transform", `translate(${xScale(d.key)}, 0)`);
                        const boxWidth = xScale.bandwidth();

                        boxG.append("line").attr("x1", boxWidth/2).attr("x2", boxWidth/2).attr("y1", yScale(d.min)).attr("y2", yScale(d.max)).attr("stroke", "var(--text-tertiary)").attr("stroke-width", 1.5);
                        boxG.append("rect").attr("x", 0).attr("y", yScale(d.q3)).attr("width", boxWidth).attr("height", yScale(d.q1) - yScale(d.q3)).attr("stroke", "var(--text-primary)").attr("stroke-width", 1.5).attr("fill", colorScale(d.key)).attr("opacity", 0.8);
                        boxG.append("line").attr("x1", 0).attr("x2", boxWidth).attr("y1", yScale(d.median)).attr("y2", yScale(d.median)).attr("stroke", "var(--text-primary)").attr("stroke-width", 2);
                    });

                }, [data, x, y, notch]);
                return <D3Chart draw={draw} dependencies={[data, x, y, notch]} />;
            },
            Heatmap: ({ data, numericCols }) => {
                const calculateCorrelationMatrix = (data, columns) => {
                    const n = columns.length;
                    const matrix = Array(n).fill(0).map(() => Array(n).fill(0));
                    for (let i = 0; i < n; i++) {
                        for (let j = i; j < n; j++) {
                            const col1 = columns[i]; const col2 = columns[j];
                            const validData = data.filter(d => d[col1] != null && d[col2] != null);
                            if (validData.length < 2) { matrix[i][j] = matrix[j][i] = 0; continue; }
                            const xSeries = validData.map(d => d[col1]); const ySeries = validData.map(d => d[col2]);
                            const meanX = d3.mean(xSeries); const meanY = d3.mean(ySeries);
                            const devX = d3.deviation(xSeries); const devY = d3.deviation(ySeries);
                            if (devX === 0 || devY === 0) { matrix[i][j] = matrix[j][i] = 0; continue; }
                            const correlation = d3.mean(xSeries.map((x_i, k) => (x_i - meanX) * (ySeries[k] - meanY))) / (devX * devY);
                            matrix[i][j] = matrix[j][i] = isNaN(correlation) ? 0 : correlation;
                        }
                    }
                    return matrix;
                };

                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;
                    
                    const selectedCols = ['price', 'horsepower', 'curb_weight', 'engine_size', 'city_mpg', 'highway_mpg', 'wheel_base', 'symboling'];
                    const matrix = calculateCorrelationMatrix(data, selectedCols);

                    const margin = { top: 100, right: 50, bottom: 50, left: 100 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;
                    
                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                    const xScale = d3.scaleBand().domain(selectedCols).range([0, width]).padding(0.05);
                    const yScale = d3.scaleBand().domain(selectedCols).range([height, 0]).padding(0.05);
                    const colorScale = d3.scaleSequential(d3.interpolateRdYlBu).domain([1, -1]);

                    g.append("g").attr("class", "axis").call(d3.axisTop(xScale)).selectAll("text").attr("transform", "rotate(-45)").style("text-anchor", "start");
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale));

                    const heatmapData = [];
                    for (let i = 0; i < selectedCols.length; i++) {
                        for (let j = 0; j < selectedCols.length; j++) {
                            heatmapData.push({ x: selectedCols[j], y: selectedCols[i], value: matrix[i][j] });
                        }
                    }

                    g.selectAll(".tile").data(heatmapData).join("rect")
                        .attr("class", "tile").attr("x", d => xScale(d.x)).attr("y", d => yScale(d.y))
                        .attr("width", xScale.bandwidth()).attr("height", yScale.bandwidth())
                        .attr("rx", 4)
                        .attr("fill", d => colorScale(d.value))
                        .on("mouseover", (event, d) => {
                            tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`);
                            tooltip.html(`Corr(${d.x.replace(/_/g, ' ')}, ${d.y.replace(/_/g, ' ')}): <b>${d.value.toFixed(2)}</b>`);
                        })
                        .on("mouseout", () => tooltip.style("opacity", 0));
                }, [data, numericCols]);
                return <D3Chart draw={draw} dependencies={[data, numericCols]} />;
            },
            '3DScatter': ({ data, x, y, z, hue }) => {
                const mountRef = useRef(null);
                const theme = document.documentElement.className;

                useEffect(() => {
                    if (!data || data.length === 0 || !mountRef.current) return;
                    
                    const currentMount = mountRef.current;
                    let animationFrameId;

                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary').trim());
                    
                    const camera = new THREE.PerspectiveCamera(60, currentMount.clientWidth / currentMount.clientHeight, 0.1, 1000);
                    camera.position.set(4, 4, 4);
                    
                    const renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
                    renderer.setPixelRatio(window.devicePixelRatio);
                    currentMount.innerHTML = '';
                    currentMount.appendChild(renderer.domElement);
                    
                    const controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;

                    const getScale = (key) => d3.scaleLinear().domain(d3.extent(data, d => d[key])).range([-2, 2]);
                    const xScale = getScale(x);
                    const yScale = getScale(y);
                    const zScale = getScale(z);
                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain([...new Set(data.map(d => d[hue]))]);

                    const geometry = new THREE.SphereGeometry(0.05, 16, 16);
                    data.forEach(d => {
                        if (d[x] == null || d[y] == null || d[z] == null) return;
                        const material = new THREE.MeshBasicMaterial({ color: colorScale(d[hue]) });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(xScale(d[x]), yScale(d[y]), zScale(d[z]));
                        scene.add(sphere);
                    });

                    const gridHelper = new THREE.GridHelper(4, 10, '#888888', '#444444');
                    scene.add(gridHelper);
                    const axesHelper = new THREE.AxesHelper(2.5);
                    scene.add(axesHelper);

                    const animate = () => {
                        animationFrameId = requestAnimationFrame(animate);
                        controls.update();
                        renderer.render(scene, camera);
                    };
                    animate();

                    const handleResize = () => {
                        if (!currentMount) return;
                        const { clientWidth: newWidth, clientHeight: newHeight } = currentMount;
                        camera.aspect = newWidth / newHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(newWidth, newHeight);
                    };
                    window.addEventListener('resize', handleResize);

                    return () => {
                        window.removeEventListener('resize', handleResize);
                        cancelAnimationFrame(animationFrameId);
                        if(currentMount) currentMount.innerHTML = '';
                        geometry.dispose();
                    };
                }, [data, x, y, z, hue, theme]);

                return <div ref={mountRef} className="three-canvas-container"></div>;
            }
        };

        // --- MAIN APP STRUCTURE ---
        const App = () => {
            const { data, loading, error, numericCols, categoricalCols } = useAutomobileData();
            const [activeChart, setActiveChart] = useState('Scatter Plot');
            const [isSidebarOpen, setSidebarOpen] = useState(false);
            const [theme, setTheme] = useState('dark'); // Default to dark theme

            useEffect(() => {
                const savedTheme = localStorage.getItem('dashboard-theme') || 'dark';
                setTheme(savedTheme);
                document.documentElement.className = savedTheme;
            }, []);

            const toggleTheme = () => {
                const newTheme = theme === 'light' ? 'dark' : 'light';
                setTheme(newTheme);
                document.documentElement.className = newTheme;
                localStorage.setItem('dashboard-theme', newTheme);
            };
            
            const [controls, setControls] = useState({
                linechart: { x: 'horsepower', y: 'price', hue: 'drive_wheels', error: 'band' },
                scatterplot: { x: 'horsepower', y: 'price', hue: 'body_style', size: 'curb_weight' },
                boxplot: { x: 'body_style', y: 'price' },
                heatmap: {},
                '3dscatter': { x: 'price', y: 'horsepower', z: 'curb_weight', hue: 'body_style' },
            });

            const handleControlChange = (chart, key, value) => {
                setControls(prev => ({ ...prev, [chart]: { ...prev[chart], [key]: value } }));
            };

            const kpiData = useMemo(() => {
                if (loading || data.length === 0) return { avgPrice: 0, topMake: 'N/A', maxHp: 0, count: 0 };
                const prices = data.map(d => d.price).filter(Boolean);
                const makes = d3.rollup(data, v => v.length, d => d.make);
                const topMake = [...makes.entries()].sort((a, b) => b[1] - a[1])[0][0];
                return {
                    avgPrice: d3.mean(prices),
                    topMake: topMake.charAt(0).toUpperCase() + topMake.slice(1),
                    maxHp: d3.max(data, d => d.horsepower),
                    count: data.length,
                };
            }, [data, loading]);

            const chartTypes = [
                { name: 'Scatter Plot', family: 'Relational Analysis' },
                { name: 'Line Chart', family: 'Relational Analysis' },
                { name: '3D Scatter', family: 'Multi-dimensional Analysis' },
                { name: 'Box Plot', family: 'Distribution Analysis' },
                { name: 'Heatmap', family: 'Correlation Analysis' },
            ];
            const groupedCharts = d3.group(chartTypes, d => d.family);

            const renderChart = () => {
                if (loading) return <div className="flex items-center justify-center h-full text-text-secondary"><div className="animate-spin rounded-full h-16 w-16 border-b-2 border-accent-primary"></div></div>;
                if (error) return <div className="flex items-center justify-center h-full text-red-500 bg-red-500/10 rounded-lg p-4"><p>{error}</p></div>;
                if (data.length === 0) return <div className="flex items-center justify-center h-full text-text-secondary"><p>No data available to display.</p></div>;
                
                const ChartComponent = ChartComponents[activeChart.replace(/ /g, '')];
                const chartControls = controls[activeChart.toLowerCase().replace(/ /g, '')];
                return <ChartComponent data={data} {...chartControls} numericCols={numericCols} categoricalCols={categoricalCols} />;
            };
            
            const ControlPanel = () => {
                const chartKey = activeChart.toLowerCase().replace(/ /g, '');
                const currentControls = controls[chartKey];
                
                if (!currentControls) {
                    return <div className="text-text-secondary col-span-full text-center py-4">No configurable options for this chart.</div>;
                }

                const renderControls = () => {
                    switch (activeChart) {
                        case 'Line Chart':
                            return <>
                                <ControlSelect label="X-Axis (Numeric)" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={numericCols} />
                                <ControlSelect label="Y-Axis (Numeric)" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} />
                                <ControlSelect label="Group By (Hue)" value={currentControls.hue} onChange={e => handleControlChange(chartKey, 'hue', e.target.value)} options={['None', ...categoricalCols]} />
                                <ControlSelect label="Error Style" value={currentControls.error} onChange={e => handleControlChange(chartKey, 'error', e.target.value)} options={['band', 'none']} />
                            </>;
                        case 'Scatter Plot':
                            return <>
                                <ControlSelect label="X-Axis" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={numericCols} />
                                <ControlSelect label="Y-Axis" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} />
                                <ControlSelect label="Color By (Hue)" value={currentControls.hue} onChange={e => handleControlChange(chartKey, 'hue', e.target.value)} options={['None', ...categoricalCols]} />
                                <ControlSelect label="Size By" value={currentControls.size} onChange={e => handleControlChange(chartKey, 'size', e.target.value)} options={['None', ...numericCols]} />
                            </>;
                        case 'Box Plot':
                            return <>
                                <ControlSelect label="Category (X-Axis)" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={categoricalCols} />
                                <ControlSelect label="Value (Y-Axis)" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} />
                            </>;
                        case '3D Scatter':
                            return <>
                                <ControlSelect label="X-Axis" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={numericCols} />
                                <ControlSelect label="Y-Axis" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} />
                                <ControlSelect label="Z-Axis" value={currentControls.z} onChange={e => handleControlChange(chartKey, 'z', e.target.value)} options={numericCols} />
                                <ControlSelect label="Color By (Hue)" value={currentControls.hue} onChange={e => handleControlChange(chartKey, 'hue', e.target.value)} options={categoricalCols} />
                            </>;
                        default: return <div className="text-text-secondary col-span-full text-center py-4">No configurable options for this chart.</div>;
                    }
                };

                return (
                    <div className="space-y-6">
                        <h3 className="text-lg font-bold text-text-primary">Chart Controls</h3>
                        <div className="grid grid-cols-1 gap-4">
                            {renderControls()}
                        </div>
                    </div>
                );
            };

            const Sidebar = () => (
                <aside className={`fixed top-0 left-0 z-40 w-64 h-screen bg-bg-secondary border-r border-border-color flex flex-col flex-shrink-0 sidebar-transition md:translate-x-0 ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                    <div className="flex items-center justify-between h-20 px-4 border-b border-border-color flex-shrink-0">
                        <h1 className="text-xl font-bold text-text-primary">Auto<span className="text-transparent bg-clip-text" style={{backgroundImage: 'var(--accent-gradient)'}}>Analytics</span></h1>
                        <button onClick={() => setSidebarOpen(false)} className="md:hidden text-text-secondary hover:text-text-primary">
                            {ICONS.Close}
                        </button>
                    </div>
                    <nav className="flex-grow p-4 overflow-y-auto">
                        {Array.from(groupedCharts.keys()).map(family => (
                            <div key={family} className="mb-6">
                                <h2 className="text-xs font-semibold text-text-tertiary uppercase tracking-wider mb-3 px-2">{family}</h2>
                                <ul>
                                    {groupedCharts.get(family).map(chart => (
                                        <li key={chart.name}>
                                            <button
                                                onClick={() => { setActiveChart(chart.name); setSidebarOpen(false); }}
                                                className={`w-full flex items-center space-x-3 px-3 py-2.5 rounded-lg text-sm font-medium transition-all duration-200 ${
                                                    activeChart === chart.name
                                                        ? 'bg-accent-primary/10 text-accent-primary font-semibold'
                                                        : 'text-text-secondary hover:bg-bg-tertiary hover:text-text-primary'
                                                }`}
                                            >
                                                {ICONS[chart.name]}
                                                <span>{chart.name}</span>
                                            </button>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        ))}
                    </nav>
                </aside>
            );

            return (
                <div className="flex h-screen bg-bg-primary font-sans">
                    <Sidebar />
                    <div className={`fixed inset-0 bg-black/60 z-30 md:hidden sidebar-transition ${isSidebarOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'}`} onClick={() => setSidebarOpen(false)}></div>
                    
                    <main className="flex-1 flex flex-col md:pl-64 transition-all duration-300">
                        <header className="flex items-center justify-between h-20 px-4 sm:px-6 lg:px-8 flex-shrink-0 border-b border-border-color bg-bg-secondary/50 backdrop-blur-sm">
                           <div className="flex items-center space-x-4">
                                <button onClick={() => setSidebarOpen(true)} className="md:hidden text-text-secondary hover:text-text-primary">
                                    {ICONS.Menu}
                                </button>
                                <div>
                                    <h2 className="text-2xl font-bold text-text-primary">{activeChart}</h2>
                                    <p className="text-sm text-text-secondary">Visualizing the 1985 Automobile Dataset</p>
                                </div>
                           </div>
                            <button onClick={toggleTheme} className="p-2 rounded-full bg-bg-tertiary text-text-secondary hover:text-text-primary hover:bg-bg-inset transition-colors">
                                {theme === 'light' ? ICONS.Moon : ICONS.Sun}
                            </button>
                        </header>

                        <div className="flex-1 p-4 sm:p-6 lg:p-8 overflow-y-auto">
                            <div className="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-6 mb-6">
                                <KpiCard title="Vehicle Count" value={loading ? '...' : kpiData.count} icon={ICONS.Car} />
                                <KpiCard title="Average Price" value={loading ? '...' : kpiData.avgPrice} format={v => `$${v.toLocaleString(undefined, {maximumFractionDigits: 0})}`} icon={ICONS.Dollar} />
                                <KpiCard title="Top Make" value={loading ? '...' : kpiData.topMake} icon={ICONS.Trophy} />
                                <KpiCard title="Max Horsepower" value={loading ? '...' : `${kpiData.maxHp} HP`} icon={ICONS.Zap} />
                            </div>

                            <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
                                <div className="xl:col-span-2 h-[65vh] chart-container">
                                   {renderChart()}
                                </div>
                                <div className="xl:col-span-1 chart-container">
                                    <ControlPanel />
                                </div>
                            </div>
                        </div>
                    </main>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
