<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automobile Data Story | Powered by Gemini</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- D3.js for 2D Charting -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Three.js for 3D Charting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            color-scheme: light;
            /* Light Theme */
            --bg-primary: #f9fafb;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f3f4f6;
            --bg-inset: #e5e7eb;
            --border-color: #e5e7eb;
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --text-tertiary: #6b7280;
            --accent-primary: #ca8a04; /* gold-600 */
            --accent-gradient: linear-gradient(to right, #facc15, #eab308);
            --shadow-color: 224 71% 4% / 0.1;
        }
        /* --- Black and Gold Theme --- */
        html.dark {
            color-scheme: dark;
            --bg-primary: #0a0a0a; /* near black */
            --bg-secondary: #1a1a1a; /* darker gray */
            --bg-tertiary: #2a2a2a; /* dark gray */
            --bg-inset: #111827;
            --border-color: #3a3a3a; /* lighter gray for borders */
            --text-primary: #f9fafb; /* off-white */
            --text-secondary: #a3a3a3; /* light gray */
            --text-tertiary: #737373; /* medium gray */
            --accent-primary: #facc15; /* gold-400 */
            --accent-gradient: linear-gradient(to right, #fde047, #facc15);
            --shadow-color: 220 90% 4% / 0.2;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-secondary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #4b5563; }

        .chart-tooltip, .info-tooltip-content {
            position: absolute;
            text-align: left;
            padding: 0.75rem;
            font-size: 0.875rem;
            background: color-mix(in srgb, var(--bg-secondary) 80%, transparent);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            border-radius: 12px;
            pointer-events: none;
            opacity: 0;
            color: var(--text-primary);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 9999;
            white-space: nowrap;
        }
        .info-tooltip-content {
            white-space: normal;
            max-width: 300px;
        }
        .chart-container {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 1rem; /* 16px */
            padding: 1.5rem; /* 24px */
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px var(--shadow-color), 0 2px 4px -2px var(--shadow-color);
            display: flex;
            flex-direction: column;
        }
        .axis path, .axis line { stroke: var(--border-color); }
        .axis text { fill: var(--text-secondary); font-size: 12px; }
        .grid-lines line { stroke: var(--border-color); stroke-opacity: 0.7; stroke-dasharray: 4,4; }
        .grid-lines path { stroke-width: 0; }
        
        .three-canvas-container { flex-grow: 1; width: 100%; height: 100%; min-height: 300px; position: relative; border-radius: 0.75rem; overflow: hidden;}
        .three-canvas-container canvas { display: block; }
        
        .label-3d {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            background: color-mix(in srgb, var(--bg-secondary) 70%, transparent);
            padding: 4px 8px;
            border-radius: 6px;
            pointer-events: none;
        }
        .sidebar-transition { transition: transform 0.3s ease-in-out; }
        
        html.dark select, html.dark option {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .gemini-story-panel {
            background: var(--accent-gradient);
            padding: 1px;
            border-radius: 0.75rem;
        }
        .gemini-story-content {
            background-color: var(--bg-secondary);
            padding: 1rem;
            border-radius: 0.7rem;
            height: 100%;
        }
    </style>
</head>
<body class="antialiased">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        // --- DATA SOURCE ---
        const DATA_URL = 'public/Rawdata/Automobile_data.csv';

        // --- DATA LOADING & PROCESSING HOOK ---
        const useAutomobileData = () => {
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            const cleanRow = useCallback((d) => {
                const newRow = {};
                for (const key in d) {
                    const newKey = key.trim().replace(/-/g, '_');
                    const val = d[key].trim();
                    if (val === '?' || val === '') {
                        newRow[newKey] = null;
                    } else {
                        const numVal = +val;
                        newRow[newKey] = isNaN(numVal) ? val : numVal;
                    }
                }
                if (!newRow.price || !newRow.horsepower || !newRow.curb_weight || !newRow.make || !newRow.body_style) {
                    return null;
                }
                return newRow;
            }, []);

            useEffect(() => {
                d3.csv(DATA_URL)
                    .then(raw => {
                        const cleanedData = raw.map(cleanRow).filter(Boolean);
                        setData(cleanedData);
                    })
                    .catch(err => {
                        console.error("Error loading or parsing data:", err);
                        setError("Failed to load dataset. Please check the file path and console for details.");
                    })
                    .finally(() => setLoading(false));
            }, [cleanRow]);
            
            const numericCols = useMemo(() => ['price', 'horsepower', 'curb_weight', 'engine_size', 'city_mpg', 'highway_mpg', 'wheel_base', 'length', 'width', 'height', 'bore', 'stroke', 'compression_ratio', 'peak_rpm', 'symboling', 'normalized_losses'].sort(), []);
            const categoricalCols = useMemo(() => ['make', 'body_style', 'fuel_type', 'aspiration', 'num_of_doors', 'drive_wheels', 'engine_location', 'engine_type', 'num_of_cylinders', 'fuel_system'].sort(), []);

            return { data, loading, error, numericCols, categoricalCols };
        };
        
        // --- UI & HELPER COMPONENTS ---
        const Tooltip = React.forwardRef((props, ref) => <div ref={ref} className="chart-tooltip"></div>);

        const Icon = ({ path, className = "w-6 h-6", strokeWidth = 1.5 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={strokeWidth} strokeLinecap="round" strokeLinejoin="round" className={className}>
                {path}
            </svg>
        );
        
        const ICONS = {
            LineChart: <Icon path={<><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline></>} />,
            ScatterPlot: <Icon path={<><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="5" r="1"></circle><circle cx="5" cy="19" r="1"></circle><circle cx="5" cy="5" r="1"></circle><circle cx="19" cy="19" r="1"></circle></>} />,
            BarChart: <Icon path={<><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></>} />,
            BoxPlot: <Icon path={<><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></>} />,
            Heatmap: <Icon path={<><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line></>} />,
            '3DScatter': <Icon path={<><path d="m21 16-4-4-4 4-4-4-4 4"/><path d="m7 12 4 4 4-4 4 4"/><path d="M3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8Z"/></>} />,
            '3DBarChart': <Icon path={<><rect x="5" y="5" width="14" height="14" rx="2" /><path d="M12 3v18" /><path d="M3 12h18" /></>} />,
            CountPlot: <Icon path={<><path d="M12 20V10"/><path d="M18 20V4"/><path d="M6 20v-4"/></>} />,
            Histogram: <Icon path={<><rect x="3" y="3" width="18" height="18" rx="2" /><path d="M9 3v18" /><path d="M15 3v18" /><path d="M3 9h18" /><path d="M3 15h18" /></>} />,
            Menu: <Icon path={<><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></>} />,
            Close: <Icon path={<><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>} />,
            Sun: <Icon path={<><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></>} className="w-5 h-5" />,
            Moon: <Icon path={<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>} className="w-5 h-5" fill="currentColor"/>,
            Car: <Icon path={<><path d="M14 16.5V15a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v1.5"></path><path d="M20 10h-2.34a2 2 0 0 0-1.97 1.66l-1.39 5.57a2 2 0 0 1-1.97 1.66H9.67a2 2 0 0 1-1.97-1.66L6.31 11.66A2 2 0 0 0 4.34 10H2"></path><path d="M17.5 10.5c.36.14.7.4.95.74.25.34.4.76.4 1.21v3.05"></path><path d="M6.5 10.5c-.36.14-.7.4-.95.74-.25.34-.4.76-.4 1.21v3.05"></path><circle cx="6" cy="19" r="2"></circle><circle cx="18" cy="19" r="2"></circle></>} />,
            Dollar: <Icon path={<><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></>} />,
            Trophy: <Icon path={<><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path><path d="M4 22h16"></path><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path></>} />,
            Zap: <Icon path={<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>} />,
            Info: <Icon path={<><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></>} className="w-5 h-5" />,
            Story: <Icon path={<><path d="M4 6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6Z"/><path d="M8 12h8"/><path d="M8 16h5"/><path d="m12 8-2 2 2 2"/></>} />,
            Explore: <Icon path={<><path d="m21 21-4.3-4.3"/><circle cx="11" cy="11" r="8"/></>} />,
            Next: <Icon path={<><polyline points="9 18 15 12 9 6"></polyline></>} className="w-5 h-5"/>,
            Prev: <Icon path={<><polyline points="15 18 9 12 15 6"></polyline></>} className="w-5 h-5"/>,
            Gemini: <Icon path={<><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></>} />,
        };

        const CHART_DESCRIPTIONS = {
            'Line Chart': 'Shows trends over a continuous interval. Best for visualizing changes in a variable (like price) against another (like horsepower).',
            'Scatter Plot': 'Displays the relationship between two numerical variables. Each dot is an observation, revealing patterns, clusters, or outliers.',
            'Bar Chart': 'Compares a numerical variable across different categories. Each bar shows an aggregate value, typically the average.',
            'Count Plot': 'A simple bar chart that shows the number of occurrences for each category. Excellent for understanding categorical data distribution.',
            'Box Plot': 'Summarizes data distribution for categories. Shows median, quartiles, and potential outliers, making it great for comparing groups.',
            'Histogram': 'Represents the distribution of a single numerical variable by grouping data into bins and counting the observations in each bin.',
            'Heatmap': 'Visualizes a matrix of data, where values are represented by colors. Perfect for showing correlations between many variables at once.',
            '3D Scatter': 'Extends a scatter plot to three dimensions, allowing for the visualization of relationships between three numerical variables.',
            '3D Bar Chart': 'Compares a numerical value across two different categorical variables in a 3D space. Useful for spotting high-level interactions.',
        };

        const InfoTooltip = ({ text }) => {
            const [visible, setVisible] = useState(false);
            const tooltipRef = useRef(null);
            const iconRef = useRef(null);

            const showTooltip = () => {
                setVisible(true);
                const iconRect = iconRef.current.getBoundingClientRect();
                const tooltipNode = tooltipRef.current;
                if (tooltipNode) {
                    tooltipNode.style.opacity = 1;
                    tooltipNode.style.transform = `translate(${iconRect.right + 10}px, ${iconRect.top}px)`;
                    tooltipNode.style.position = 'fixed';
                    tooltipNode.style.left = `${iconRect.right + 10}px`;
                    tooltipNode.style.top = `${iconRect.top}px`;
                }
            };
            const hideTooltip = () => setVisible(false);

            return (
                <div className="relative inline-block ml-2">
                    <button ref={iconRef} onMouseEnter={showTooltip} onMouseLeave={hideTooltip} className="text-text-tertiary hover:text-text-primary transition-colors">
                        {ICONS.Info}
                    </button>
                    {visible && ReactDOM.createPortal(
                        <div ref={tooltipRef} className="info-tooltip-content">
                            {text}
                        </div>,
                        document.body
                    )}
                </div>
            );
        };

        const KpiCard = ({ title, value, icon, format }) => (
            <div className="bg-bg-secondary p-5 rounded-xl border border-border-color flex items-center space-x-4 transition-all duration-300 hover:shadow-lg hover:-translate-y-1">
                <div className="p-3 rounded-lg bg-accent-primary/10 text-accent-primary">
                    {icon}
                </div>
                <div>
                    <p className="text-sm text-text-secondary font-medium">{title}</p>
                    <p className="text-2xl font-bold text-text-primary">{format ? format(value) : value}</p>
                </div>
            </div>
        );
        
        const ControlSelect = ({ label, value, onChange, options, disabled=false }) => (
            <div>
                <label className="block text-sm font-medium text-text-secondary mb-1.5 capitalize">{label.replace(/_/g, ' ')}</label>
                <div className="relative">
                    <select 
                        value={value} 
                        onChange={onChange} 
                        disabled={disabled} 
                        className="appearance-none w-full p-2.5 bg-bg-tertiary text-text-primary border border-border-color rounded-lg shadow-sm focus:ring-2 focus:ring-accent-primary focus:border-accent-primary disabled:opacity-50 disabled:cursor-not-allowed transition-colors pr-8"
                    >
                        {options.map(opt => <option key={opt} value={opt}>{opt.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</option>)}
                    </select>
                    <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-text-secondary">
                        <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                            <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
                        </svg>
                    </div>
                </div>
            </div>
        );
        
        // --- D3 CHARTING LOGIC (REUSABLE) ---
        const D3Chart = ({ draw, dependencies, className }) => {
            const svgRef = useRef();
            const tooltipRef = useRef();

            useEffect(() => {
                const svg = d3.select(svgRef.current);
                const tooltip = d3.select(tooltipRef.current);
                
                if (!svg.node()) return;

                let resizeTimer;
                const handleResize = () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => {
                        if (svg.node()) draw(svg, tooltip);
                    }, 150);
                };
                
                draw(svg, tooltip);

                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [draw, ...dependencies]);

            return (
                <div className={`relative w-full h-full flex-grow ${className || ''}`}>
                    <svg ref={svgRef} className="w-full h-full" />
                    <Tooltip ref={tooltipRef} />
                </div>
            );
        };

        // --- CHART COMPONENTS ---
        const ChartComponents = {
            LineChart: ({ data, x, y, hue }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 150, bottom: 60, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;
                    
                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                    const xScale = d3.scaleLinear().domain(d3.extent(data, d => d[x])).range([0, width]).nice();
                    const yScale = d3.scaleLinear().domain(d3.extent(data, d => d[y])).range([height, 0]).nice();
                    const groupedData = hue !== 'None' ? d3.group(data, d => d[hue]) : [['all', data]];
                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(Array.from(groupedData.keys()));

                    g.append("g").attr("class", "grid-lines").call(d3.axisLeft(yScale).ticks(5).tickSize(-width).tickFormat(""));
                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale).ticks(Math.min(10, width/80))).append("text").attr("y", 45).attr("x", width/2).attr("fill", "currentColor").attr("text-anchor", "middle").attr("font-size", "14px").text(x.replace(/_/g, ' '));
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale)).append("text").attr("transform", "rotate(-90)").attr("y", -50).attr("x", -height/2).attr("fill", "currentColor").attr("text-anchor", "middle").attr("font-size", "14px").text(y.replace(/_/g, ' '));
                    
                    groupedData.forEach((groupData, key) => {
                        const sortedGroup = groupData.sort((a,b) => a[x] - b[x]);
                        const aggregatedData = Array.from(d3.group(sortedGroup, d => d[x]), ([xVal, yVals]) => ({ x: xVal, y: d3.mean(yVals, d => d[y]) })).filter(d => d.y !== undefined);
                        g.append("path").datum(aggregatedData).attr("fill", "none").attr("stroke", colorScale(key)).attr("stroke-width", 2.5).attr("d", d3.line().x(d => xScale(d.x)).y(d => yScale(d.y)));
                        g.selectAll(`.dot-${key}`).data(aggregatedData).enter().append("circle").attr("class", `dot-${key}`).attr("cx", d => xScale(d.x)).attr("cy", d => yScale(d.y)).attr("r", 5).attr("fill", "transparent")
                            .on("mouseover", (event, d) => {
                                tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`).html(`<strong class="text-base" style="color: var(--text-primary);">${key}</strong><br><span class="capitalize">${x.replace(/_/g, ' ')}</span>: ${d.x}<br><span class="capitalize">${y.replace(/_/g, ' ')}</span>: ${d.y.toFixed(0)}`);
                            }).on("mouseout", () => tooltip.style("opacity", 0));
                    });

                    if (hue !== 'None') {
                        const legend = g.selectAll(".legend").data(colorScale.domain()).enter().append("g").attr("class", "legend").attr("transform", (d, i) => `translate(${width + 30},${i * 25})`);
                        legend.append("rect").attr("x", 0).attr("width", 18).attr("height", 18).attr("rx", 4).style("fill", colorScale);
                        legend.append("text").attr("x", 24).attr("y", 9).attr("dy", ".35em").style("text-anchor", "start").text(d => d).attr("fill", "var(--text-secondary)");
                    }
                }, [data, x, y, hue]);
                return <D3Chart draw={draw} dependencies={[data, x, y, hue]} />;
            },
            ScatterPlot: ({ data, x, y, hue, size }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 150, bottom: 60, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;
                    
                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                    const xScale = d3.scaleLinear().domain(d3.extent(data, d => d[x])).range([0, width]).nice();
                    const yScale = d3.scaleLinear().domain(d3.extent(data, d => d[y])).range([height, 0]).nice();
                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(hue !== 'None' ? [...new Set(data.map(d => d[hue]))].sort() : ['all']);
                    const sizeScale = d3.scaleLinear().domain(size !== 'None' ? d3.extent(data, d => d[size]) : [1,1]).range([4, 15]);

                    g.append("g").attr("class", "grid-lines").call(d3.axisLeft(yScale).ticks(5).tickSize(-width).tickFormat(""));
                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale).ticks(Math.min(10, width/80))).append("text").attr("y", 45).attr("x", width/2).attr("fill", "currentColor").attr("text-anchor", "middle").attr("font-size", "14px").text(x.replace(/_/g, ' '));
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale)).append("text").attr("transform", "rotate(-90)").attr("y", -50).attr("x", -height/2).attr("fill", "currentColor").attr("text-anchor", "middle").attr("font-size", "14px").text(y.replace(/_/g, ' '));

                    g.selectAll("circle").data(data).join("circle")
                        .attr("cx", d => xScale(d[x])).attr("cy", d => yScale(d[y]))
                        .attr("r", d => sizeScale(size !== 'None' ? d[size] : 1))
                        .attr("fill", d => colorScale(hue !== 'None' ? d[hue] : 'var(--accent-primary)'))
                        .attr("opacity", 0.7).attr("stroke", "var(--bg-secondary)").attr("stroke-width", 1.5)
                        .on("mouseover", (event, d) => {
                            tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`).html(`<strong class="text-base" style="color: var(--text-primary);">${d.make}</strong><br><span class="capitalize">${x.replace(/_/g, ' ')}</span>: ${d[x]}<br><span class="capitalize">${y.replace(/_/g, ' ')}</span>: ${d[y]}${hue !== 'None' ? `<br><span class="capitalize">${hue.replace(/_/g, ' ')}</span>: ${d[hue]}` : ''}${size !== 'None' ? `<br><span class="capitalize">${size.replace(/_/g, ' ')}</span>: ${d[size]}` : ''}`);
                        }).on("mouseout", () => tooltip.style("opacity", 0));
                    
                    if (hue !== 'None') {
                        const legend = g.selectAll(".legend").data(colorScale.domain()).enter().append("g").attr("class", "legend").attr("transform", (d, i) => `translate(${width + 30},${i * 25})`);
                        legend.append("rect").attr("x", 0).attr("width", 18).attr("height", 18).attr("rx", 4).style("fill", colorScale);
                        legend.append("text").attr("x", 24).attr("y", 9).attr("dy", ".35em").style("text-anchor", "start").text(d => d).attr("fill", "var(--text-secondary)");
                    }
                }, [data, x, y, hue, size]);
                return <D3Chart draw={draw} dependencies={[data, x, y, hue, size]} />;
            },
            BarChart: ({ data, x, y }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 30, bottom: 100, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;

                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                    
                    const aggregatedData = Array.from(d3.group(data, d => d[x]), ([key, value]) => ({ key, value: d3.mean(value, d => d[y]) }));
                    aggregatedData.sort((a, b) => b.value - a.value);

                    const xScale = d3.scaleBand().domain(aggregatedData.map(d => d.key)).range([0, width]).padding(0.2);
                    const yScale = d3.scaleLinear().domain([0, d3.max(aggregatedData, d => d.value)]).range([height, 0]).nice();

                    g.append("g").attr("class", "grid-lines").call(d3.axisLeft(yScale).ticks(5).tickSize(-width).tickFormat(""));
                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale))
                        .selectAll("text").attr("transform", "rotate(-45)").style("text-anchor", "end");
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale));

                    g.selectAll(".bar").data(aggregatedData).join("rect")
                        .attr("class", "bar").attr("x", d => xScale(d.key)).attr("y", d => yScale(d.value))
                        .attr("width", xScale.bandwidth()).attr("height", d => height - yScale(d.value))
                        .attr("fill", "var(--accent-primary)")
                        .on("mouseover", (event, d) => {
                            tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`).html(`<strong class="text-base" style="color: var(--text-primary);">${d.key}</strong><br>Avg ${y.replace(/_/g, ' ')}: ${d.value.toFixed(0)}`);
                        }).on("mouseout", () => tooltip.style("opacity", 0));
                }, [data, x, y]);
                return <D3Chart draw={draw} dependencies={[data, x, y]} />;
            },
            CountPlot: ({ data, x }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 30, bottom: 100, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                     if (width <= 0 || height <= 0) return;

                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                    const counts = d3.rollup(data, v => v.length, d => d[x]);
                    const aggregatedData = Array.from(counts, ([key, value]) => ({key, value})).sort((a,b) => b.value - a.value);
                    
                    const xScale = d3.scaleBand().domain(aggregatedData.map(d => d.key)).range([0, width]).padding(0.2);
                    const yScale = d3.scaleLinear().domain([0, d3.max(aggregatedData, d => d.value)]).range([height, 0]).nice();

                    g.append("g").attr("class", "grid-lines").call(d3.axisLeft(yScale).ticks(5).tickSize(-width).tickFormat(""));
                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale))
                        .selectAll("text").attr("transform", "rotate(-45)").style("text-anchor", "end");
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale));

                    g.selectAll(".bar").data(aggregatedData).join("rect")
                        .attr("class", "bar").attr("x", d => xScale(d.key)).attr("y", d => yScale(d.value))
                        .attr("width", xScale.bandwidth()).attr("height", d => height - yScale(d.value))
                        .attr("fill", "var(--accent-primary)")
                        .on("mouseover", (event, d) => {
                            tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`).html(`<strong class="text-base" style="color: var(--text-primary);">${d.key}</strong><br>Count: ${d.value}`);
                        }).on("mouseout", () => tooltip.style("opacity", 0));
                }, [data, x]);
                return <D3Chart draw={draw} dependencies={[data, x]} />;
            },
            BoxPlot: ({ data, x, y }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 30, bottom: 100, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;
                    
                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                    const groupedData = d3.group(data, d => d[x]);
                    const summaryStats = [];
                    groupedData.forEach((groupData, key) => {
                        const sortedValues = groupData.map(d => d[y]).filter(v => v != null).sort(d3.ascending);
                        if(sortedValues.length === 0) return;
                        const q1 = d3.quantile(sortedValues, 0.25);
                        const median = d3.quantile(sortedValues, 0.5);
                        const q3 = d3.quantile(sortedValues, 0.75);
                        if ([q1, median, q3].some(v => v === undefined)) return;
                        const iqr = q3 - q1;
                        const min = Math.max(d3.min(sortedValues), q1 - 1.5 * iqr);
                        const max = Math.min(d3.max(sortedValues), q3 + 1.5 * iqr);
                        summaryStats.push({ key, q1, median, q3, min, max });
                    });
                    summaryStats.sort((a,b) => a.median - b.median);

                    const xScale = d3.scaleBand().domain(summaryStats.map(d => d.key)).range([0, width]).padding(0.4);
                    const yScale = d3.scaleLinear().domain([0, d3.max(data, d => d[y])]).range([height, 0]).nice();
                    
                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale))
                        .selectAll("text").attr("transform", "rotate(-45)").style("text-anchor", "end");
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale));
                    g.append("g").attr("class", "grid-lines").call(d3.axisLeft(yScale).ticks(5).tickSize(-width).tickFormat(""));
                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(summaryStats.map(d => d.key));

                    summaryStats.forEach(d => {
                        const boxG = g.append("g").attr("transform", `translate(${xScale(d.key)}, 0)`);
                        const boxWidth = xScale.bandwidth();
                        boxG.append("line").attr("x1", boxWidth/2).attr("x2", boxWidth/2).attr("y1", yScale(d.min)).attr("y2", yScale(d.max)).attr("stroke", "var(--text-tertiary)").attr("stroke-width", 1.5);
                        boxG.append("rect").attr("x", 0).attr("y", yScale(d.q3)).attr("width", boxWidth).attr("height", yScale(d.q1) - yScale(d.q3)).attr("stroke", "var(--text-primary)").attr("stroke-width", 1.5).attr("fill", colorScale(d.key)).attr("opacity", 0.8);
                        boxG.append("line").attr("x1", 0).attr("x2", boxWidth).attr("y1", yScale(d.median)).attr("y2", yScale(d.median)).attr("stroke", "var(--text-primary)").attr("stroke-width", 2);
                        boxG.append("rect").attr("x", 0).attr("y", 0).attr("width", boxWidth).attr("height", height).attr("fill", "transparent")
                            .on("mouseover", (event) => {
                                tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`).html(`<strong class="text-base" style="color: var(--text-primary);">${d.key}</strong><br>Max: ${d.max.toFixed(0)}<br>Q3: ${d.q3.toFixed(0)}<br>Median: ${d.median.toFixed(0)}<br>Q1: ${d.q1.toFixed(0)}<br>Min: ${d.min.toFixed(0)}`);
                            }).on("mouseout", () => tooltip.style("opacity", 0));
                    });
                }, [data, x, y]);
                return <D3Chart draw={draw} dependencies={[data, x, y]} />;
            },
            Histogram: ({ data, x, bins }) => {
                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;

                    const margin = { top: 30, right: 30, bottom: 60, left: 70 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;

                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                    const values = data.map(d => d[x]).filter(d => d != null);
                    const xScale = d3.scaleLinear().domain(d3.extent(values)).range([0, width]).nice();
                    const histogram = d3.bin().value(d => d).domain(xScale.domain()).thresholds(xScale.ticks(bins));
                    const binData = histogram(values);
                    const yScale = d3.scaleLinear().domain([0, d3.max(binData, d => d.length)]).range([height, 0]).nice();

                    g.append("g").attr("class", "axis").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale));
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale));
                    
                    g.selectAll("rect").data(binData).join("rect")
                        .attr("x", d => xScale(d.x0) + 1)
                        .attr("width", d => Math.max(0, xScale(d.x1) - xScale(d.x0) - 1))
                        .attr("y", d => yScale(d.length))
                        .attr("height", d => height - yScale(d.length))
                        .attr("fill", "var(--accent-primary)")
                        .on("mouseover", (event, d) => {
                            tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`).html(`Range: ${d.x0.toFixed(0)}-${d.x1.toFixed(0)}<br>Count: ${d.length}`);
                        }).on("mouseout", () => tooltip.style("opacity", 0));
                }, [data, x, bins]);
                return <D3Chart draw={draw} dependencies={[data, x, bins]} />;
            },
            Heatmap: ({ data, numericCols }) => {
                const calculateCorrelationMatrix = (data, columns) => {
                    const n = columns.length;
                    const matrix = Array(n).fill(0).map(() => Array(n).fill(0));
                    for (let i = 0; i < n; i++) {
                        for (let j = i; j < n; j++) {
                            const col1 = columns[i]; const col2 = columns[j];
                            const validData = data.filter(d => d[col1] != null && d[col2] != null);
                            if (validData.length < 2) { matrix[i][j] = matrix[j][i] = 0; continue; }
                            const xSeries = validData.map(d => d[col1]); const ySeries = validData.map(d => d[col2]);
                            const meanX = d3.mean(xSeries); const meanY = d3.mean(ySeries);
                            const devX = d3.deviation(xSeries); const devY = d3.deviation(ySeries);
                            if (devX === 0 || devY === 0) { matrix[i][j] = matrix[j][i] = 0; continue; }
                            const correlation = d3.mean(xSeries.map((x_i, k) => (x_i - meanX) * (ySeries[k] - meanY))) / (devX * devY);
                            matrix[i][j] = matrix[j][i] = isNaN(correlation) ? 0 : correlation;
                        }
                    }
                    return matrix;
                };

                const draw = useCallback((svg, tooltip) => {
                    svg.selectAll("*").remove();
                    if (!data || data.length === 0) return;
                    
                    const selectedCols = ['price', 'horsepower', 'curb_weight', 'engine_size', 'city_mpg', 'highway_mpg', 'wheel_base'];
                    const matrix = calculateCorrelationMatrix(data, selectedCols);

                    const margin = { top: 100, right: 50, bottom: 50, left: 100 };
                    const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                    const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                    if (width <= 0 || height <= 0) return;
                    
                    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                    const xScale = d3.scaleBand().domain(selectedCols).range([0, width]).padding(0.05);
                    const yScale = d3.scaleBand().domain(selectedCols).range([height, 0]).padding(0.05);
                    const colorScale = d3.scaleSequential(d3.interpolateRdYlBu).domain([1, -1]);

                    g.append("g").attr("class", "axis").call(d3.axisTop(xScale)).selectAll("text").attr("transform", "rotate(-45)").style("text-anchor", "start");
                    g.append("g").attr("class", "axis").call(d3.axisLeft(yScale));

                    const heatmapData = [];
                    for (let i = 0; i < selectedCols.length; i++) {
                        for (let j = 0; j < selectedCols.length; j++) {
                            heatmapData.push({ x: selectedCols[j], y: selectedCols[i], value: matrix[i][j] });
                        }
                    }

                    g.selectAll(".tile").data(heatmapData).join("rect")
                        .attr("class", "tile").attr("x", d => xScale(d.x)).attr("y", d => yScale(d.y))
                        .attr("width", xScale.bandwidth()).attr("height", yScale.bandwidth())
                        .attr("rx", 4).attr("fill", d => colorScale(d.value))
                        .on("mouseover", (event, d) => {
                            tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`).html(`Corr(${d.x.replace(/_/g, ' ')}, ${d.y.replace(/_/g, ' ')}): <b>${d.value.toFixed(2)}</b>`);
                        }).on("mouseout", () => tooltip.style("opacity", 0));
                }, [data, numericCols]);
                return <D3Chart draw={draw} dependencies={[data, numericCols]} />;
            },
            '3DScatter': ({ data, x, y, z, hue }) => {
                const mountRef = useRef(null);
                const theme = document.documentElement.className;

                useEffect(() => {
                    if (!data || data.length === 0 || !mountRef.current) return;
                    
                    const currentMount = mountRef.current;
                    let animationFrameId;

                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary').trim());
                    
                    const camera = new THREE.PerspectiveCamera(60, currentMount.clientWidth / currentMount.clientHeight, 0.1, 1000);
                    camera.position.set(4, 4, 4);
                    
                    const renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
                    renderer.setPixelRatio(window.devicePixelRatio);
                    currentMount.innerHTML = '';
                    currentMount.appendChild(renderer.domElement);
                    
                    const controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;

                    const getScale = (key) => d3.scaleLinear().domain(d3.extent(data, d => d[key])).range([-2, 2]);
                    const xScale = getScale(x);
                    const yScale = getScale(y);
                    const zScale = getScale(z);
                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain([...new Set(data.map(d => d[hue]))]);

                    const geometry = new THREE.SphereGeometry(0.05, 16, 16);
                    data.forEach(d => {
                        if (d[x] == null || d[y] == null || d[z] == null) return;
                        const material = new THREE.MeshBasicMaterial({ color: colorScale(d[hue]) });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(xScale(d[x]), yScale(d[y]), zScale(d[z]));
                        scene.add(sphere);
                    });

                    const gridHelper = new THREE.GridHelper(4, 10, '#888888', '#444444');
                    scene.add(gridHelper);
                    const axesHelper = new THREE.AxesHelper(2.5);
                    scene.add(axesHelper);

                    const animate = () => {
                        animationFrameId = requestAnimationFrame(animate);
                        controls.update();
                        renderer.render(scene, camera);
                    };
                    animate();

                    const handleResize = () => {
                        if (!currentMount) return;
                        const { clientWidth: newWidth, clientHeight: newHeight } = currentMount;
                        camera.aspect = newWidth / newHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(newWidth, newHeight);
                    };
                    window.addEventListener('resize', handleResize);

                    return () => {
                        window.removeEventListener('resize', handleResize);
                        cancelAnimationFrame(animationFrameId);
                        if(currentMount) currentMount.innerHTML = '';
                        geometry.dispose();
                    };
                }, [data, x, y, z, hue, theme]);

                return <div ref={mountRef} className="three-canvas-container"></div>;
            },
            '3DBarChart': ({ data, x, y, z }) => {
                const mountRef = useRef(null);
                const theme = document.documentElement.className;

                useEffect(() => {
                    if (!data || data.length === 0 || !mountRef.current) return;
                    
                    const currentMount = mountRef.current;
                    let animationFrameId;

                    // --- Data Processing ---
                    const aggregatedData = Array.from(d3.group(data, d => d[x], d => d[z]), 
                        ([xKey, zValues]) => {
                            return Array.from(zValues, ([zKey, values]) => ({
                                x: xKey,
                                z: zKey,
                                y: d3.mean(values, v => v[y])
                            }));
                        }
                    ).flat();
                    
                    const xCategories = [...new Set(aggregatedData.map(d => d.x))].sort();
                    const zCategories = [...new Set(aggregatedData.map(d => d.z))].sort();
                    const yMax = d3.max(aggregatedData, d => d.y);

                    // --- Scene Setup ---
                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary').trim());
                    
                    const camera = new THREE.PerspectiveCamera(50, currentMount.clientWidth / currentMount.clientHeight, 0.1, 1000);
                    camera.position.set(xCategories.length * 1.5, yMax * 0.0002, zCategories.length * 1.5);
                    
                    const renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
                    renderer.setPixelRatio(window.devicePixelRatio);
                    
                    const labelRenderer = new THREE.CSS2DRenderer();
                    labelRenderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
                    labelRenderer.domElement.style.position = 'absolute';
                    labelRenderer.domElement.style.top = '0px';
                    labelRenderer.domElement.style.pointerEvents = 'none';

                    currentMount.innerHTML = '';
                    currentMount.appendChild(renderer.domElement);
                    currentMount.appendChild(labelRenderer.domElement);

                    const controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    
                    // --- Lighting ---
                    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(5, 10, 7.5);
                    scene.add(directionalLight);

                    // --- Scales and Colors ---
                    const xScale = d3.scalePoint().domain(xCategories).range([-xCategories.length/2, xCategories.length/2]);
                    const zScale = d3.scalePoint().domain(zCategories).range([-zCategories.length/2, zCategories.length/2]);
                    const yScale = d3.scaleLinear().domain([0, yMax]).range([0, 8]);
                    const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(xCategories);

                    // --- Create Bars ---
                    const barGeometry = new THREE.BoxGeometry(0.8, 1, 0.8);
                    aggregatedData.forEach(d => {
                        const barHeight = yScale(d.y);
                        if (isNaN(barHeight) || barHeight <= 0) return;
                        
                        const material = new THREE.MeshStandardMaterial({ color: colorScale(d.x), roughness: 0.5, metalness: 0.2 });
                        const bar = new THREE.Mesh(barGeometry, material);
                        bar.scale.y = barHeight;
                        bar.position.set(xScale(d.x), barHeight / 2, zScale(d.z));
                        scene.add(bar);
                    });

                    // --- Grid and Axes Labels ---
                    const gridHelper = new THREE.GridHelper(Math.max(xCategories.length, zCategories.length) + 2, Math.max(xCategories.length, zCategories.length) + 2, '#888888', '#444444');
                    scene.add(gridHelper);

                    const createLabel = (text) => {
                        const div = document.createElement('div');
                        div.className = 'label-3d';
                        div.textContent = text;
                        return new THREE.CSS2DObject(div);
                    };
                    
                    xCategories.forEach(cat => {
                        const label = createLabel(cat);
                        label.position.set(xScale(cat), -0.2, zCategories.length / 2 + 1);
                        scene.add(label);
                    });
                    zCategories.forEach(cat => {
                        const label = createLabel(cat);
                        label.position.set(xCategories.length / 2 + 1, -0.2, zScale(cat));
                        label.rotation.y = -Math.PI / 2;
                        scene.add(label);
                    });
                     // Y-Axis Labels
                    for (let i = 0; i <= 5; i++) {
                        const value = (yMax / 5) * i;
                        const label = createLabel(value.toFixed(0));
                        label.position.set(xCategories.length / 2 + 1, yScale(value), zCategories.length / 2 + 1);
                        scene.add(label);
                    }

                    // --- Animation Loop ---
                    const animate = () => {
                        animationFrameId = requestAnimationFrame(animate);
                        controls.update();
                        renderer.render(scene, camera);
                        labelRenderer.render(scene, camera);
                    };
                    animate();

                    const handleResize = () => {
                        if (!currentMount) return;
                        const { clientWidth: newWidth, clientHeight: newHeight } = currentMount;
                        camera.aspect = newWidth / newHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(newWidth, newHeight);
                        labelRenderer.setSize(newWidth, newHeight);
                    };
                    window.addEventListener('resize', handleResize);

                    return () => {
                        window.removeEventListener('resize', handleResize);
                        cancelAnimationFrame(animationFrameId);
                        if(currentMount) currentMount.innerHTML = '';
                        barGeometry.dispose();
                    };
                }, [data, x, y, z, theme]);

                return <div ref={mountRef} className="three-canvas-container"></div>;
            }
        };

        // --- MAIN APP STRUCTURE ---
        const App = () => {
            const { data, loading, error, numericCols, categoricalCols } = useAutomobileData();
            const [activeChart, setActiveChart] = useState('Scatter Plot');
            const [isSidebarOpen, setSidebarOpen] = useState(false);
            const [theme, setTheme] = useState('dark');
            const [viewMode, setViewMode] = useState('story'); // 'story', 'explore'
            const [storyStep, setStoryStep] = useState(0);
            
            // --- STORY DEFINITION ---
            const story = useMemo(() => [
                { title: "Chapter 1: The Manufacturers", narrative: "Welcome! Let's start by seeing which brands are most represented in this 1985 dataset. Toyota, Nissan, and Mazda lead the pack, indicating their strong market presence at the time.", chartType: 'Count Plot', config: { x: 'make' } },
                { title: "Chapter 2: The Price Landscape", narrative: "What did cars cost back then? This histogram shows most cars were priced between $5,000 and $13,000. There's a long tail of more expensive luxury vehicles, suggesting a competitive market for budget-friendly cars.", chartType: 'Histogram', config: { x: 'price', bins: 30 } },
                { title: "Chapter 3: Power vs. Price", narrative: "A key factor in price is performance. Here, we see a clear positive correlation: as horsepower increases, so does the price. Sedans and hardtops tend to reach higher price and power points.", chartType: 'Scatter Plot', config: { x: 'horsepower', y: 'price', hue: 'body_style', size: 'curb_weight' } },
                { title: "Chapter 4: The Performance Triangle", narrative: "Let's add a third dimension: fuel efficiency (Highway MPG). In this 3D plot, you can see the trade-offs. The most expensive, powerful cars (top-right) have lower MPG (closer to you). Explore the cloud to find the sweet spots!", chartType: '3D Scatter', config: { x: 'price', y: 'horsepower', z: 'highway_mpg', hue: 'body_style' } },
                { title: "Chapter 5: A New Dimension", narrative: "This 3D Bar Chart shows average price across body styles and drive-wheel types. Rear-wheel drive (rwd) convertibles are, on average, the most expensive. Four-wheel drive (4wd) is mostly limited to wagons.", chartType: '3D Bar Chart', config: { x: 'drive_wheels', z: 'body_style', y: 'price' } },
                { title: "Chapter 6: Brand Price Tiers", narrative: "How do brands compare on price? This box plot reveals the price range for each. Mercedes-Benz, BMW, and Jaguar occupy the high-end, while brands like Chevrolet and Honda are on the budget-friendly side.", chartType: 'Box Plot', config: { x: 'make', y: 'price' } },
                { title: "Chapter 7: The Big Picture", narrative: "Finally, this heatmap shows correlations between features. Red means a strong positive correlation (e.g., price and horsepower), blue means a strong negative one (e.g., horsepower and MPG). This concludes our tour. Feel free to exit Story Mode to explore on your own!", chartType: 'Heatmap', config: {} },
            ], []);

            const [controls, setControls] = useState({
                linechart: { x: 'horsepower', y: 'price', hue: 'drive_wheels' },
                scatterplot: { x: 'horsepower', y: 'price', hue: 'body_style', size: 'curb_weight' },
                barchart: { x: 'make', y: 'price' },
                countplot: { x: 'make' },
                boxplot: { x: 'make', y: 'price' },
                histogram: { x: 'price', bins: 20 },
                heatmap: {},
                '3dscatter': { x: 'price', y: 'horsepower', z: 'highway_mpg', hue: 'body_style' },
                '3dbarchart': { x: 'drive_wheels', z: 'body_style', y: 'price' },
            });

            // Effect to update chart when in story mode
            useEffect(() => {
                if (viewMode === 'story') {
                    const currentStep = story[storyStep];
                    setActiveChart(currentStep.chartType);
                    const chartKey = currentStep.chartType.toLowerCase().replace(/ /g, '');
                    setControls(prev => ({ ...prev, [chartKey]: currentStep.config }));
                }
            }, [viewMode, storyStep, story]);


            const handleControlChange = (chart, key, value) => {
                setControls(prev => ({ ...prev, [chart]: { ...prev[chart], [key]: value } }));
            };

            const kpiData = useMemo(() => {
                if (loading || data.length === 0) return { avgPrice: 0, topMake: 'N/A', maxHp: 0, count: 0 };
                const prices = data.map(d => d.price).filter(Boolean);
                const makes = d3.rollup(data, v => v.length, d => d.make);
                const topMake = makes.size > 0 ? [...makes.entries()].sort((a, b) => b[1] - a[1])[0][0] : 'N/A';
                return {
                    avgPrice: d3.mean(prices) || 0,
                    topMake: topMake.charAt(0).toUpperCase() + topMake.slice(1),
                    maxHp: d3.max(data, d => d.horsepower) || 0,
                    count: data.length,
                };
            }, [data, loading]);

            const chartTypes = [
                { name: 'Scatter Plot', family: 'Relational' },
                { name: 'Line Chart', family: 'Relational' },
                { name: 'Bar Chart', family: 'Categorical' },
                { name: 'Count Plot', family: 'Categorical' },
                { name: 'Box Plot', family: 'Categorical' },
                { name: 'Histogram', family: 'Distribution' },
                { name: 'Heatmap', family: 'Matrix' },
                { name: '3D Scatter', family: 'Multi-dimensional' },
                { name: '3D Bar Chart', family: 'Multi-dimensional' },
            ];
            const groupedCharts = d3.group(chartTypes, d => d.family);

            const renderChart = () => {
                if (loading) return <div className="flex items-center justify-center h-full text-text-secondary"><div className="animate-spin rounded-full h-16 w-16 border-b-2 border-accent-primary"></div></div>;
                if (error) return <div className="flex items-center justify-center h-full text-red-500 bg-red-500/10 rounded-lg p-4"><p>{error}</p></div>;
                if (data.length === 0) return <div className="flex items-center justify-center h-full text-text-secondary"><p>No data available to display.</p></div>;
                
                const ChartComponent = ChartComponents[activeChart.replace(/ /g, '')];
                const chartControls = controls[activeChart.toLowerCase().replace(/ /g, '')];
                return <ChartComponent data={data} {...chartControls} numericCols={numericCols} categoricalCols={categoricalCols} />;
            };
            
            const ControlPanel = () => {
                const chartKey = activeChart.toLowerCase().replace(/ /g, '');
                const currentControls = controls[chartKey];
                
                if (!currentControls) return <div className="text-text-secondary col-span-full text-center py-4">No configurable options for this chart.</div>;
                
                const renderControls = () => {
                    switch (activeChart) {
                        case 'Line Chart': return <> <ControlSelect label="X-Axis (Numeric)" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={numericCols} /> <ControlSelect label="Y-Axis (Numeric)" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} /> <ControlSelect label="Group By (Hue)" value={currentControls.hue} onChange={e => handleControlChange(chartKey, 'hue', e.target.value)} options={['None', ...categoricalCols]} /> </>;
                        case 'Scatter Plot': return <> <ControlSelect label="X-Axis" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={numericCols} /> <ControlSelect label="Y-Axis" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} /> <ControlSelect label="Color By (Hue)" value={currentControls.hue} onChange={e => handleControlChange(chartKey, 'hue', e.target.value)} options={['None', ...categoricalCols]} /> <ControlSelect label="Size By" value={currentControls.size} onChange={e => handleControlChange(chartKey, 'size', e.target.value)} options={['None', ...numericCols]} /> </>;
                        case 'Bar Chart': return <> <ControlSelect label="Category (X-Axis)" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={categoricalCols} /> <ControlSelect label="Value (Y-Axis)" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} /> </>;
                        case 'Count Plot': return <ControlSelect label="Category (X-Axis)" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={categoricalCols} />;
                        case 'Box Plot': return <> <ControlSelect label="Category (X-Axis)" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={categoricalCols} /> <ControlSelect label="Value (Y-Axis)" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} /> </>;
                        case 'Histogram': return <> <ControlSelect label="Variable" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={numericCols} /> <div><label className="block text-sm font-medium text-text-secondary mb-1.5">Bins</label><input type="range" min="5" max="50" value={currentControls.bins} onChange={e => handleControlChange(chartKey, 'bins', +e.target.value)} className="w-full" /></div> </>;
                        case '3D Scatter': return <> <ControlSelect label="X-Axis" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={numericCols} /> <ControlSelect label="Y-Axis" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} /> <ControlSelect label="Z-Axis" value={currentControls.z} onChange={e => handleControlChange(chartKey, 'z', e.target.value)} options={numericCols} /> <ControlSelect label="Color By (Hue)" value={currentControls.hue} onChange={e => handleControlChange(chartKey, 'hue', e.target.value)} options={categoricalCols} /> </>;
                        case '3D Bar Chart': return <> <ControlSelect label="X-Axis" value={currentControls.x} onChange={e => handleControlChange(chartKey, 'x', e.target.value)} options={categoricalCols} /> <ControlSelect label="Y-Axis (Height)" value={currentControls.y} onChange={e => handleControlChange(chartKey, 'y', e.target.value)} options={numericCols} /> <ControlSelect label="Z-Axis" value={currentControls.z} onChange={e => handleControlChange(chartKey, 'z', e.target.value)} options={categoricalCols} /> </>;
                        default: return <div className="text-text-secondary col-span-full text-center py-4">No configurable options for this chart.</div>;
                    }
                };

                return (
                    <div className="space-y-6">
                        <h3 className="text-lg font-bold text-text-primary">Chart Controls</h3>
                        <div className="grid grid-cols-1 gap-4">
                            {renderControls()}
                        </div>
                    </div>
                );
            };

            const StoryPanel = () => {
                const currentStepData = story[storyStep];
                return (
                     <div className="flex flex-col justify-between h-full">
                        <div>
                            <h3 className="text-lg font-bold text-text-primary mb-1">{currentStepData.title}</h3>
                            <p className="text-sm text-text-secondary mb-4">Step {storyStep + 1} of {story.length}</p>
                            <p className="text-base text-text-primary leading-relaxed">{currentStepData.narrative}</p>
                        </div>
                        <div className="mt-6 flex items-center justify-between">
                            <button 
                                onClick={() => setStoryStep(s => Math.max(0, s - 1))}
                                disabled={storyStep === 0}
                                className="flex items-center space-x-2 px-4 py-2 rounded-lg bg-bg-tertiary hover:bg-bg-inset disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                            >
                                {ICONS.Prev}
                                <span>Prev</span>
                            </button>
                             <button 
                                onClick={() => setStoryStep(s => Math.min(story.length - 1, s + 1))}
                                disabled={storyStep === story.length - 1}
                                className="flex items-center space-x-2 px-4 py-2 rounded-lg bg-accent-primary text-white hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                            >
                                <span>Next</span>
                                {ICONS.Next}
                            </button>
                        </div>
                    </div>
                );
            };
            
            const GeminiStoryPanel = () => {
                const [geminiStory, setGeminiStory] = useState("");
                const [geminiLoading, setGeminiLoading] = useState(false);
                const [geminiError, setGeminiError] = useState(null);

                const generateStory = async () => {
                    setGeminiLoading(true);
                    setGeminiError(null);
                    setGeminiStory("");

                    const chartKey = activeChart.toLowerCase().replace(/ /g, '');
                    const currentControls = controls[chartKey];

                    // Summarize data to keep prompt concise
                    let dataSummary = `The dataset contains ${data.length} vehicles from 1985.`;
                    const controlEntries = Object.entries(currentControls);
                    if(controlEntries.length > 0) {
                        dataSummary += " The current chart variables are: ";
                        dataSummary += controlEntries.map(([key, value]) => `${key}: ${value}`).join(', ');
                    }
                    
                    const prompt = `You are an expert data analyst. Your task is to provide a short, insightful narrative based on a visualization of a 1985 automobile dataset.
                    
                    Current Visualization:
                    - Chart Type: ${activeChart}
                    - Data Summary: ${dataSummary}
                    
                    Based on this context, write a 2-3 sentence story that explains a key insight, pattern, or relationship revealed by this specific view of the data. Be concise and clear. Start your story with a clear topic sentence.`;

                    try {
                         let chatHistory = [];
                         chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                         const payload = { contents: chatHistory };
                         const apiKey = "" // API key will be injected by the environment
                         const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                         const response = await fetch(apiUrl, {
                             method: 'POST',
                             headers: { 'Content-Type': 'application/json' },
                             body: JSON.stringify(payload)
                         });
                         
                         if (!response.ok) {
                             throw new Error(`API request failed with status ${response.status}`);
                         }

                         const result = await response.json();
                         
                         if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                            const text = result.candidates[0].content.parts[0].text;
                            setGeminiStory(text);
                         } else {
                            throw new Error("Invalid response structure from API.");
                         }

                    } catch (err) {
                        console.error("Gemini API error:", err);
                        setGeminiError("Sorry, I couldn't generate a story right now. Please try again.");
                    } finally {
                        setGeminiLoading(false);
                    }
                };

                return (
                    <div className="space-y-4">
                        <h3 className="text-lg font-bold text-text-primary flex items-center">
                            <span className="text-transparent bg-clip-text mr-2" style={{backgroundImage: 'var(--accent-gradient)'}}>
                                {ICONS.Gemini}
                            </span>
                            Ask Gemini
                        </h3>
                        <p className="text-sm text-text-secondary">Let Gemini analyze the current chart and generate a story about the data's insights.</p>
                        <button 
                            onClick={generateStory}
                            disabled={geminiLoading}
                            className="w-full flex items-center justify-center space-x-2 px-4 py-2.5 rounded-lg bg-accent-primary text-white font-semibold hover:opacity-90 disabled:opacity-50 disabled:cursor-not-allowed transition-all"
                        >
                            {geminiLoading ? (
                                <>
                                 <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                                 <span>Generating...</span>
                                </>
                            ) : (
                                <>
                                 {ICONS.Gemini}
                                 <span>Generate Story with Gemini</span>
                                </>
                            )}
                        </button>
                        
                        {geminiStory && (
                             <div className="gemini-story-panel mt-4">
                                <div className="gemini-story-content">
                                    <p className="text-base text-text-primary leading-relaxed">{geminiStory}</p>
                                </div>
                            </div>
                        )}
                        {geminiError && <p className="text-sm text-red-500 mt-2">{geminiError}</p>}
                    </div>
                );
            };

            const Sidebar = () => (
                <aside className={`fixed top-0 left-0 z-40 w-64 h-screen bg-bg-secondary border-r border-border-color flex flex-col flex-shrink-0 sidebar-transition md:translate-x-0 ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                    <div className="flex items-center justify-between h-20 px-4 border-b border-border-color flex-shrink-0">
                        <h1 className="text-xl font-bold text-text-primary">Auto<span className="text-transparent bg-clip-text" style={{backgroundImage: 'var(--accent-gradient)'}}>Story</span></h1>
                        <button onClick={() => setSidebarOpen(false)} className="md:hidden text-text-secondary hover:text-text-primary">
                            {ICONS.Close}
                        </button>
                    </div>
                    <nav className="flex-grow p-4 overflow-y-auto">
                        {Array.from(groupedCharts.keys()).map(family => (
                            <div key={family} className="mb-6">
                                <h2 className="text-xs font-semibold text-text-tertiary uppercase tracking-wider mb-3 px-2">{family}</h2>
                                <ul>
                                    {groupedCharts.get(family).map(chart => (
                                        <li key={chart.name}>
                                            <button
                                                onClick={() => { setActiveChart(chart.name); setSidebarOpen(false); setViewMode('explore'); }}
                                                className={`w-full flex items-center space-x-3 px-3 py-2.5 rounded-lg text-sm font-medium transition-all duration-200 ${
                                                    activeChart === chart.name && viewMode === 'explore'
                                                        ? 'bg-accent-primary/10 text-accent-primary font-semibold'
                                                        : 'text-text-secondary hover:bg-bg-tertiary hover:text-text-primary'
                                                }`}
                                            >
                                                {ICONS[chart.name.replace(/ /g, '')]}
                                                <span>{chart.name}</span>
                                            </button>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        ))}
                    </nav>
                </aside>
            );

            useEffect(() => {
                const savedTheme = localStorage.getItem('dashboard-theme') || 'dark';
                setTheme(savedTheme);
                document.documentElement.className = savedTheme;
            }, []);

            const toggleTheme = () => {
                const newTheme = theme === 'light' ? 'dark' : 'light';
                setTheme(newTheme);
                document.documentElement.className = newTheme;
                localStorage.setItem('dashboard-theme', newTheme);
            };

            return (
                <div className="flex h-screen bg-bg-primary font-sans">
                    <Sidebar />
                    <div className={`fixed inset-0 bg-black/60 z-30 md:hidden sidebar-transition ${isSidebarOpen ? 'opacity-100' : 'opacity-0 pointer-events-none'}`} onClick={() => setSidebarOpen(false)}></div>
                    
                    <main className="flex-1 flex flex-col md:pl-64 transition-all duration-300">
                        <header className="flex items-center justify-between h-20 px-4 sm:px-6 lg:px-8 flex-shrink-0 border-b border-border-color bg-bg-secondary/50 backdrop-blur-sm z-10">
                           <div className="flex items-center space-x-4">
                                <button onClick={() => setSidebarOpen(true)} className="md:hidden text-text-secondary hover:text-text-primary">
                                    {ICONS.Menu}
                                </button>
                                <div>
                                    <h2 className="text-2xl font-bold text-text-primary flex items-center">
                                        {activeChart}
                                        {CHART_DESCRIPTIONS[activeChart] && <InfoTooltip text={CHART_DESCRIPTIONS[activeChart]} />}
                                    </h2>
                                    <p className="text-sm text-text-secondary">Visualizing the 1985 Automobile Dataset</p>
                                </div>
                           </div>
                           <div className="flex items-center space-x-2">
                                <div className="flex items-center rounded-lg bg-bg-tertiary p-1">
                                    <button 
                                        onClick={() => setViewMode('story')}
                                        className={`flex items-center space-x-2 px-3 py-1.5 rounded-md text-sm font-semibold transition-colors ${viewMode === 'story' ? 'bg-bg-secondary shadow-sm text-accent-primary' : 'text-text-secondary hover:text-text-primary'}`}
                                    >
                                        {ICONS.Story}
                                        <span>Story</span>
                                    </button>
                                     <button 
                                        onClick={() => setViewMode('explore')}
                                        className={`flex items-center space-x-2 px-3 py-1.5 rounded-md text-sm font-semibold transition-colors ${viewMode === 'explore' ? 'bg-bg-secondary shadow-sm text-accent-primary' : 'text-text-secondary hover:text-text-primary'}`}
                                    >
                                        {ICONS.Explore}
                                        <span>Explore</span>
                                    </button>
                                </div>
                                <button onClick={toggleTheme} className="p-2 rounded-full bg-bg-tertiary text-text-secondary hover:text-text-primary hover:bg-bg-inset transition-colors">
                                    {theme === 'light' ? ICONS.Moon : ICONS.Sun}
                                </button>
                           </div>
                        </header>

                        <div className="flex-1 p-4 sm:p-6 lg:p-8 overflow-y-auto">
                            <div className="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-6 mb-6">
                                <KpiCard title="Vehicle Count" value={loading ? '...' : kpiData.count} icon={ICONS.Car} />
                                <KpiCard title="Average Price" value={loading ? '...' : kpiData.avgPrice} format={v => `$${v.toLocaleString(undefined, {maximumFractionDigits: 0})}`} icon={ICONS.Dollar} />
                                <KpiCard title="Top Make" value={loading ? '...' : kpiData.topMake} icon={ICONS.Trophy} />
                                <KpiCard title="Max Horsepower" value={loading ? '...' : `${kpiData.maxHp} HP`} icon={ICONS.Zap} />
                            </div>

                            <div className="grid grid-cols-1 xl:grid-cols-3 gap-6">
                                <div className="xl:col-span-2 min-h-[65vh] chart-container">
                                   {renderChart()}
                                </div>
                                <div className="xl:col-span-1 chart-container">
                                    {viewMode === 'story' ? <StoryPanel /> : 
                                        <div className="flex flex-col space-y-6 h-full">
                                            <div className="flex-shrink-0"><ControlPanel /></div>
                                            <div className="border-t border-border-color my-4"></div>
                                            <div className="flex-grow"><GeminiStoryPanel /></div>
                                        </div>
                                    }
                                </div>
                            </div>
                        </div>
                    </main>
                </div>
            );
        };

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
