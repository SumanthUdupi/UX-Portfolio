<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Automobile Insights Dashboard</title>

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- D3.js for 2D Charting -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Three.js for 3D Charting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-primary: #F1F5F9; /* slate-100 */
            --bg-secondary: #FFFFFF; /* white */
            --bg-sidebar: #0F172A; /* slate-900 */
            --border-color: #CBD5E1; /* slate-300 */
            --text-primary: #1E293B; /* slate-800 */
            --text-secondary: #475569; /* slate-600 */
            --text-sidebar: #94A3B8; /* slate-400 */
            --accent-primary: #0EA5E9; /* sky-500 */
            --accent-secondary: #6366F1; /* indigo-500 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
        }
        /* Modern Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        .chart-tooltip {
            position: absolute;
            text-align: left;
            padding: 0.75rem;
            font-size: 0.875rem;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(4px);
            border: 1px solid var(--accent-primary);
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            color: white;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 9999;
            white-space: nowrap;
        }
        .chart-container {
             background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        .axis path, .axis line { stroke: var(--border-color); }
        .axis text { fill: var(--text-secondary); font-size: 12px; }
        .grid-lines line { stroke: #e2e8f0; stroke-opacity: 0.7; stroke-dasharray: 2,2; }
        .grid-lines path { stroke-width: 0; }
        .three-canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        .three-canvas-container canvas {
            display: block;
        }
        .label-3d {
            color: var(--text-secondary);
            font-size: 12px;
            background: rgba(255, 255, 255, 0.7);
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body class="antialiased">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback, forwardRef } = React;

        // --- Data Loading and Processing Hook ---
        const DATA_URL = 'public/Rawdata/Automobile_data.csv';

        const useAutomobileData = () => {
            const [data, setData] = useState([]);
            const [loading, setLoading] = useState(true);

            const cleanRow = (d) => {
                const newRow = {};
                for (const key in d) {
                    const newKey = key.trim();
                    const val = d[key].trim();
                    if (val === '?' || val === '') {
                        newRow[newKey] = null;
                    } else {
                        newRow[newKey] = isNaN(+val) ? val : +val;
                    }
                }
                // Ensure essential fields for charting are present
                if (!newRow.price || !newRow.horsepower || !newRow['curb-weight'] || !newRow.make || !newRow['body-style']) {
                    return null;
                }
                return newRow;
            };

            useEffect(() => {
                d3.csv(DATA_URL).then(raw => {
                    const cleanedData = raw.map(cleanRow).filter(d => d);
                    setData(cleanedData);
                    setLoading(false);
                }).catch(error => {
                    console.error("Error loading or parsing data:", error);
                    setLoading(false);
                });
            }, []);
            
            const numericCols = useMemo(() => ['price', 'horsepower', 'curb-weight', 'engine-size', 'city-mpg', 'highway-mpg', 'wheel-base', 'length', 'width', 'height', 'bore', 'stroke', 'compression-ratio', 'peak-rpm', 'symboling', 'normalized-losses'], []);
            const categoricalCols = useMemo(() => ['make', 'body-style', 'fuel-type', 'aspiration', 'num-of-doors', 'drive-wheels', 'engine-location', 'engine-type', 'num-of-cylinders', 'fuel-system'], []);

            return { data, loading, numericCols, categoricalCols };
        };
        
        // --- Utility & Helper Components ---
        const Tooltip = forwardRef((props, ref) => <div ref={ref} className="chart-tooltip"></div>);
        
        const ControlSelect = ({ label, value, onChange, options, disabled=false }) => (
            <div>
                <label className="block text-sm font-medium text-gray-500 mb-1">{label}</label>
                <select value={value} onChange={onChange} disabled={disabled} className="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100 disabled:cursor-not-allowed">
                    {options.map(opt => <option key={opt} value={opt}>{opt.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}</option>)}
                </select>
            </div>
        );

        const ControlToggle = ({ label, checked, onChange, disabled=false }) => (
            <div className="flex items-center justify-between">
                <span className="text-sm font-medium text-gray-500">{label}</span>
                <label className="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" checked={checked} onChange={onChange} disabled={disabled} className="sr-only peer" />
                    <div className="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
        );

        // --- D3 Charting Logic (Hooks) ---
        // This hook encapsulates the D3 logic for drawing a chart and handling updates.
        const useD3 = (renderChartFn, dependencies) => {
            const ref = useRef();
            useEffect(() => {
                renderChartFn(d3.select(ref.current));
                return () => {};
            }, dependencies);
            return ref;
        };

        // --- Chart Components ---

        // Base component for all 2D charts to handle SVG setup, dimensions, and tooltips
        const D3Chart = ({ draw, dependencies, className }) => {
            const svgRef = useRef();
            const tooltipRef = useRef();

            useEffect(() => {
                const svg = d3.select(svgRef.current);
                const tooltip = d3.select(tooltipRef.current);
                
                // Debounced resize handler
                let resizeTimer;
                const handleResize = () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => {
                        draw(svg, tooltip);
                    }, 200);
                };
                
                draw(svg, tooltip);

                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [draw, ...dependencies]);

            return (
                <div className={`relative w-full h-full ${className || ''}`}>
                    <svg ref={svgRef} className="w-full h-full" />
                    <Tooltip ref={tooltipRef} />
                </div>
            );
        };

        // 1. Line Chart
        const LineChart = ({ data, xVar, yVar, hueVar, errorStyle }) => {
            const draw = useCallback((svg, tooltip) => {
                svg.selectAll("*").remove();
                if (!data || data.length === 0) return;

                const margin = { top: 20, right: 100, bottom: 50, left: 60 };
                const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                
                const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                const xScale = d3.scaleLinear().domain(d3.extent(data, d => d[xVar])).range([0, width]).nice();
                const yScale = d3.scaleLinear().domain(d3.extent(data, d => d[yVar])).range([height, 0]).nice();
                const colorScale = d3.scaleOrdinal(d3.schemeTableau10);

                g.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale)).append("text").attr("y", 40).attr("x", width/2).attr("fill", "currentColor").attr("text-anchor", "middle").text(xVar);
                g.append("g").call(d3.axisLeft(yScale)).append("text").attr("transform", "rotate(-90)").attr("y", -45).attr("x", -height/2).attr("fill", "currentColor").attr("text-anchor", "middle").text(yVar);

                const groupedData = hueVar !== 'None' ? d3.group(data, d => d[hueVar]) : [['all', data]];
                colorScale.domain(Array.from(groupedData.keys()));

                groupedData.forEach((groupData, key) => {
                    const sortedGroup = groupData.sort((a,b) => a[xVar] - b[xVar]);
                    
                    // Aggregate data to handle multiple y values for a single x
                    const aggregatedData = Array.from(d3.group(sortedGroup, d => d[xVar]), ([xVal, yVals]) => {
                        const mean = d3.mean(yVals, d => d[yVar]);
                        const std = d3.deviation(yVals, d => d[yVar]);
                        return { x: xVal, y: mean, y0: mean - std, y1: mean + std };
                    }).filter(d => d.y !== undefined);

                    // Error band
                    if(errorStyle === 'band' && aggregatedData.length > 1){
                        g.append("path")
                            .datum(aggregatedData)
                            .attr("fill", colorScale(key))
                            .attr("opacity", 0.2)
                            .attr("d", d3.area().x(d => xScale(d.x)).y0(d => yScale(d.y0)).y1(d => yScale(d.y1)));
                    }

                    // Main line
                    g.append("path")
                        .datum(aggregatedData)
                        .attr("fill", "none")
                        .attr("stroke", colorScale(key))
                        .attr("stroke-width", 2)
                        .attr("d", d3.line().x(d => xScale(d.x)).y(d => yScale(d.y)));
                    
                    // Legend
                    g.append("circle").attr("cx",width + 10).attr("cy",colorScale.domain().indexOf(key)*25).attr("r", 6).style("fill", colorScale(key))
                    g.append("text").attr("x", width + 20).attr("y", colorScale.domain().indexOf(key)*25).text(key).style("font-size", "12px").attr("alignment-baseline","middle")
                });
            }, [data, xVar, yVar, hueVar, errorStyle]);

            return <D3Chart draw={draw} dependencies={[data, xVar, yVar, hueVar, errorStyle]} />;
        };
        
        // 2. Scatter Plot
        const ScatterPlot = ({ data, xVar, yVar, hueVar, sizeVar }) => {
            const draw = useCallback((svg, tooltip) => {
                svg.selectAll("*").remove();
                if (!data || data.length === 0) return;

                const margin = { top: 20, right: 100, bottom: 50, left: 60 };
                const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                
                const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                const xScale = d3.scaleLinear().domain(d3.extent(data, d => d[xVar])).range([0, width]).nice();
                const yScale = d3.scaleLinear().domain(d3.extent(data, d => d[yVar])).range([height, 0]).nice();
                const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(hueVar !== 'None' ? [...new Set(data.map(d => d[hueVar]))].sort() : ['all']);
                const sizeScale = d3.scaleLinear().domain(sizeVar !== 'None' ? d3.extent(data, d => d[sizeVar]) : [1,1]).range([3, 12]);

                g.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale)).append("text").attr("y", 40).attr("x", width/2).attr("fill", "currentColor").attr("text-anchor", "middle").text(xVar);
                g.append("g").call(d3.axisLeft(yScale)).append("text").attr("transform", "rotate(-90)").attr("y", -45).attr("x", -height/2).attr("fill", "currentColor").attr("text-anchor", "middle").text(yVar);

                g.selectAll("circle")
                    .data(data)
                    .join("circle")
                    .attr("cx", d => xScale(d[xVar]))
                    .attr("cy", d => yScale(d[yVar]))
                    .attr("r", d => sizeScale(sizeVar !== 'None' ? d[sizeVar] : 1))
                    .attr("fill", d => colorScale(hueVar !== 'None' ? d[hueVar] : 'all'))
                    .attr("opacity", 0.7)
                    .on("mouseover", (event, d) => {
                        tooltip.style("opacity", 1)
                               .style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`);
                        tooltip.html(`
                            <strong>${d.make}</strong><br>
                            ${xVar}: ${d[xVar]}<br>
                            ${yVar}: ${d[yVar]}
                            ${hueVar !== 'None' ? `<br>${hueVar}: ${d[hueVar]}` : ''}
                            ${sizeVar !== 'None' ? `<br>${sizeVar}: ${d[sizeVar]}` : ''}
                        `);
                    })
                    .on("mouseout", () => tooltip.style("opacity", 0));
                
                if (hueVar !== 'None') {
                    const legend = g.selectAll(".legend").data(colorScale.domain()).enter().append("g")
                        .attr("class", "legend").attr("transform", (d, i) => `translate(${width + 10},${i * 20})`);
                    legend.append("rect").attr("x", 0).attr("width", 18).attr("height", 18).style("fill", colorScale);
                    legend.append("text").attr("x", 24).attr("y", 9).attr("dy", ".35em").style("text-anchor", "start").text(d => d);
                }

            }, [data, xVar, yVar, hueVar, sizeVar]);

            return <D3Chart draw={draw} dependencies={[data, xVar, yVar, hueVar, sizeVar]} />;
        };
        
        // 11. Box Plot
        const BoxPlot = ({ data, xVar, yVar, notch }) => {
            const draw = useCallback((svg, tooltip) => {
                svg.selectAll("*").remove();
                if (!data || data.length === 0) return;

                const margin = { top: 20, right: 30, bottom: 80, left: 60 };
                const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                
                const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                const groupedData = d3.group(data, d => d[xVar]);
                const summaryStats = [];
                groupedData.forEach((groupData, key) => {
                    const sortedValues = groupData.map(d => d[yVar]).sort(d3.ascending);
                    const q1 = d3.quantile(sortedValues, 0.25);
                    const median = d3.quantile(sortedValues, 0.5);
                    const q3 = d3.quantile(sortedValues, 0.75);
                    if ([q1, median, q3].some(v => v === undefined)) return;
                    const iqr = q3 - q1;
                    const min = Math.max(d3.min(sortedValues), q1 - 1.5 * iqr);
                    const max = Math.min(d3.max(sortedValues), q3 + 1.5 * iqr);
                    const n = sortedValues.length;
                    const notchOffset = 1.57 * iqr / Math.sqrt(n);
                    summaryStats.push({ key, q1, median, q3, min, max, notchUpper: median + notchOffset, notchLower: median - notchOffset });
                });
                summaryStats.sort((a,b) => d3.ascending(a.key, b.key));

                const xScale = d3.scaleBand().domain(summaryStats.map(d => d.key)).range([0, width]).padding(0.4);
                const yScale = d3.scaleLinear().domain([0, d3.max(data, d => d[yVar])]).range([height, 0]).nice();
                
                g.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(xScale))
                    .selectAll("text").attr("transform", "rotate(-45)").style("text-anchor", "end");
                g.append("g").call(d3.axisLeft(yScale));

                summaryStats.forEach(d => {
                    const boxG = g.append("g").attr("transform", `translate(${xScale(d.key)}, 0)`);
                    const boxWidth = xScale.bandwidth();

                    // Whiskers
                    boxG.append("line").attr("x1", boxWidth/2).attr("x2", boxWidth/2).attr("y1", yScale(d.min)).attr("y2", yScale(d.max)).attr("stroke", "black");
                    boxG.append("line").attr("x1", 0).attr("x2", boxWidth).attr("y1", yScale(d.min)).attr("y2", yScale(d.min)).attr("stroke", "black");
                    boxG.append("line").attr("x1", 0).attr("x2", boxWidth).attr("y1", yScale(d.max)).attr("y2", yScale(d.max)).attr("stroke", "black");

                    // Box or Notched Box
                    if (notch) {
                        boxG.append("path")
                           .attr("d", `
                                M 0 ${yScale(d.q3)}
                                H ${boxWidth}
                                V ${yScale(d.notchUpper)}
                                L ${boxWidth/2} ${yScale(d.median)}
                                L 0 ${yScale(d.notchUpper)}
                                V ${yScale(d.q1)}
                                L ${boxWidth/2} ${yScale(d.median)}
                                L ${boxWidth} ${yScale(d.q1)}
                                V ${yScale(d.notchLower)}
                                L ${boxWidth/2} ${yScale(d.median)}
                                L 0 ${yScale(d.notchLower)}
                                Z
                           `)
                           .attr("stroke", "black").attr("fill", "var(--accent-primary)");
                    } else {
                        boxG.append("rect").attr("x", 0).attr("y", yScale(d.q3)).attr("width", boxWidth).attr("height", yScale(d.q1) - yScale(d.q3)).attr("stroke", "black").attr("fill", "var(--accent-primary)");
                        boxG.append("line").attr("x1", 0).attr("x2", boxWidth).attr("y1", yScale(d.median)).attr("y2", yScale(d.median)).attr("stroke", "black").attr("stroke-width", 2);
                    }
                });

            }, [data, xVar, yVar, notch]);
            return <D3Chart draw={draw} dependencies={[data, xVar, yVar, notch]} />;
        };
        
        // 18. Heatmap
        const Heatmap = ({ data, numericCols }) => {
            const calculateCorrelationMatrix = (data, columns) => {
                const n = columns.length;
                const matrix = Array(n).fill(0).map(() => Array(n).fill(0));
                for (let i = 0; i < n; i++) {
                    for (let j = i; j < n; j++) {
                        const col1 = columns[i];
                        const col2 = columns[j];
                        const validData = data.filter(d => d[col1] != null && d[col2] != null);
                        if (validData.length < 2) {
                            matrix[i][j] = matrix[j][i] = 0;
                            continue;
                        }
                        const xSeries = validData.map(d => d[col1]);
                        const ySeries = validData.map(d => d[col2]);
                        const meanX = d3.mean(xSeries);
                        const meanY = d3.mean(ySeries);
                        const devX = d3.deviation(xSeries);
                        const devY = d3.deviation(ySeries);

                        if (devX === 0 || devY === 0) {
                             matrix[i][j] = matrix[j][i] = 0;
                             continue;
                        }
                        
                        const correlation = d3.mean(xSeries.map((x_i, k) => (x_i - meanX) * (ySeries[k] - meanY))) / (devX * devY);
                        matrix[i][j] = matrix[j][i] = isNaN(correlation) ? 0 : correlation;
                    }
                }
                return matrix;
            };

            const draw = useCallback((svg, tooltip) => {
                svg.selectAll("*").remove();
                if (!data || data.length === 0) return;
                
                const selectedCols = ['price', 'horsepower', 'curb-weight', 'engine-size', 'city-mpg', 'highway-mpg', 'wheel-base', 'symboling'];
                const matrix = calculateCorrelationMatrix(data, selectedCols);

                const margin = { top: 50, right: 50, bottom: 100, left: 100 };
                const width = svg.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = svg.node().getBoundingClientRect().height - margin.top - margin.bottom;
                
                const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

                const xScale = d3.scaleBand().domain(selectedCols).range([0, width]).padding(0.05);
                const yScale = d3.scaleBand().domain(selectedCols).range([height, 0]).padding(0.05);
                const colorScale = d3.scaleSequential(d3.interpolateRdBu).domain([-1, 1]);

                g.append("g").call(d3.axisTop(xScale)).selectAll("text").attr("transform", "rotate(-45)").style("text-anchor", "start");
                g.append("g").call(d3.axisLeft(yScale));

                const heatmapData = [];
                for (let i = 0; i < selectedCols.length; i++) {
                    for (let j = 0; j < selectedCols.length; j++) {
                        heatmapData.push({ x: selectedCols[i], y: selectedCols[j], value: matrix[i][j] });
                    }
                }

                g.selectAll(".tile").data(heatmapData).join("rect")
                    .attr("class", "tile")
                    .attr("x", d => xScale(d.x)).attr("y", d => yScale(d.y))
                    .attr("width", xScale.bandwidth()).attr("height", yScale.bandwidth())
                    .attr("fill", d => colorScale(d.value))
                    .on("mouseover", (event, d) => {
                        tooltip.style("opacity", 1).style("transform", `translate(${event.pageX + 15}px, ${event.pageY}px)`);
                        tooltip.html(`Corr(${d.x}, ${d.y}): <b>${d.value.toFixed(2)}</b>`);
                    })
                    .on("mouseout", () => tooltip.style("opacity", 0));

            }, [data, numericCols]);
            return <D3Chart draw={draw} dependencies={[data, numericCols]} />;
        };

        // 3D Scatter Plot
        const ScatterPlot3D = ({ data, xVar, yVar, zVar, hueVar }) => {
            const mountRef = useRef(null);

            useEffect(() => {
                if (!data || data.length === 0 || !mountRef.current) return;
                
                const currentMount = mountRef.current;
                const { clientWidth: width, clientHeight: height } = currentMount;

                // Scene, Camera, Renderer
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf1f5f9);
                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.z = 5;
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                currentMount.innerHTML = '';
                currentMount.appendChild(renderer.domElement);
                
                const labelRenderer = new THREE.CSS2DRenderer();
                labelRenderer.setSize(width, height);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0px';
                currentMount.appendChild(labelRenderer.domElement);

                // Controls
                const controls = new THREE.OrbitControls(camera, labelRenderer.domElement);
                controls.enableDamping = true;

                // Data Scaling
                const getScale = (key) => d3.scaleLinear().domain(d3.extent(data, d => d[key])).range([-2, 2]);
                const xScale = getScale(xVar);
                const yScale = getScale(yVar);
                const zScale = getScale(zVar);
                const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain([...new Set(data.map(d => d[hueVar]))]);

                // Add points
                data.forEach(d => {
                    if (d[xVar] == null || d[yVar] == null || d[zVar] == null) return;
                    const geometry = new THREE.SphereGeometry(0.05, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color: colorScale(d[hueVar]) });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(xScale(d[xVar]), yScale(d[yVar]), zScale(d[zVar]));
                    scene.add(sphere);
                });

                // Axes Helper
                const axesHelper = new THREE.AxesHelper(2.5);
                scene.add(axesHelper);
                
                // Axes Labels
                const createLabel = (text, position) => {
                    const div = document.createElement('div');
                    div.className = 'label-3d';
                    div.textContent = text;
                    const label = new THREE.CSS2DObject(div);
                    label.position.copy(position);
                    return label;
                };
                scene.add(createLabel(xVar, new THREE.Vector3(2.7, 0, 0)));
                scene.add(createLabel(yVar, new THREE.Vector3(0, 2.7, 0)));
                scene.add(createLabel(zVar, new THREE.Vector3(0, 0, 2.7)));

                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                    labelRenderer.render(scene, camera);
                };
                animate();

                // Handle resize
                const handleResize = () => {
                    const { clientWidth: newWidth, clientHeight: newHeight } = currentMount;
                    camera.aspect = newWidth / newHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(newWidth, newHeight);
                    labelRenderer.setSize(newWidth, newHeight);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    if(currentMount) currentMount.innerHTML = '';
                };
            }, [data, xVar, yVar, zVar, hueVar]);

            return <div ref={mountRef} className="three-canvas-container"></div>;
        };

        // --- Main App Component ---
        const App = () => {
            const { data, loading, numericCols, categoricalCols } = useAutomobileData();
            const [activeChart, setActiveChart] = useState('Scatter Plot');
            
            // State for chart controls
            const [controls, setControls] = useState({
                line: { x: 'horsepower', y: 'price', hue: 'drive-wheels', error: 'band' },
                scatter: { x: 'horsepower', y: 'price', hue: 'body-style', size: 'curb-weight' },
                box: { x: 'body-style', y: 'price', notch: true },
                heatmap: {},
                scatter3d: { x: 'price', y: 'horsepower', z: 'curb-weight', hue: 'body-style' },
            });

            const handleControlChange = (chart, key, value) => {
                setControls(prev => ({
                    ...prev,
                    [chart]: { ...prev[chart], [key]: value }
                }));
            };

            const chartTypes = [
                { name: 'Line Chart', family: 'Relational' },
                { name: 'Scatter Plot', family: 'Relational' },
                { name: 'Box Plot', family: 'Distribution' },
                { name: 'Heatmap', family: 'Matrix' },
                { name: '3D Scatter', family: '3D' },
            ];
            
            const groupedCharts = d3.group(chartTypes, d => d.family);

            const renderChart = () => {
                if (loading) return <div className="flex items-center justify-center h-full"><p className="text-lg">Loading Data...</p></div>;
                if (data.length === 0 && !loading) return <div className="flex items-center justify-center h-full"><p className="text-lg text-red-500">Failed to load data.</p></div>;

                switch (activeChart) {
                    case 'Line Chart':
                        return <LineChart data={data} xVar={controls.line.x} yVar={controls.line.y} hueVar={controls.line.hue} errorStyle={controls.line.error} />;
                    case 'Scatter Plot':
                        return <ScatterPlot data={data} xVar={controls.scatter.x} yVar={controls.scatter.y} hueVar={controls.scatter.hue} sizeVar={controls.scatter.size} />;
                    case 'Box Plot':
                        return <BoxPlot data={data} xVar={controls.box.x} yVar={controls.box.y} notch={controls.box.notch} />;
                    case 'Heatmap':
                        return <Heatmap data={data} numericCols={numericCols} />;
                    case '3D Scatter':
                        return <ScatterPlot3D data={data} xVar={controls.scatter3d.x} yVar={controls.scatter3d.y} zVar={controls.scatter3d.z} hueVar={controls.scatter3d.hue} />;
                    default:
                        return <div className="text-center">Select a chart type</div>;
                }
            };
            
            const renderControls = () => {
                switch (activeChart) {
                    case 'Line Chart':
                        return <>
                            <ControlSelect label="X-Axis" value={controls.line.x} onChange={e => handleControlChange('line', 'x', e.target.value)} options={numericCols} />
                            <ControlSelect label="Y-Axis" value={controls.line.y} onChange={e => handleControlChange('line', 'y', e.target.value)} options={numericCols} />
                            <ControlSelect label="Hue" value={controls.line.hue} onChange={e => handleControlChange('line', 'hue', e.target.value)} options={['None', ...categoricalCols]} />
                            <ControlSelect label="Error Style" value={controls.line.error} onChange={e => handleControlChange('line', 'error', e.target.value)} options={['band', 'none']} />
                        </>;
                    case 'Scatter Plot':
                        return <>
                            <ControlSelect label="X-Axis" value={controls.scatter.x} onChange={e => handleControlChange('scatter', 'x', e.target.value)} options={numericCols} />
                            <ControlSelect label="Y-Axis" value={controls.scatter.y} onChange={e => handleControlChange('scatter', 'y', e.target.value)} options={numericCols} />
                            <ControlSelect label="Hue (Color)" value={controls.scatter.hue} onChange={e => handleControlChange('scatter', 'hue', e.target.value)} options={['None', ...categoricalCols]} />
                            <ControlSelect label="Size" value={controls.scatter.size} onChange={e => handleControlChange('scatter', 'size', e.target.value)} options={['None', ...numericCols]} />
                        </>;
                    case 'Box Plot':
                        return <>
                            <ControlSelect label="Category (X-Axis)" value={controls.box.x} onChange={e => handleControlChange('box', 'x', e.target.value)} options={categoricalCols} />
                            <ControlSelect label="Value (Y-Axis)" value={controls.box.y} onChange={e => handleControlChange('box', 'y', e.target.value)} options={numericCols} />
                            <ControlToggle label="Show Notch" checked={controls.box.notch} onChange={e => handleControlChange('box', 'notch', e.target.checked)} />
                        </>;
                    case '3D Scatter':
                        return <>
                            <ControlSelect label="X-Axis" value={controls.scatter3d.x} onChange={e => handleControlChange('scatter3d', 'x', e.target.value)} options={numericCols} />
                            <ControlSelect label="Y-Axis" value={controls.scatter3d.y} onChange={e => handleControlChange('scatter3d', 'y', e.target.value)} options={numericCols} />
                            <ControlSelect label="Z-Axis" value={controls.scatter3d.z} onChange={e => handleControlChange('scatter3d', 'z', e.target.value)} options={numericCols} />
                            <ControlSelect label="Hue (Color)" value={controls.scatter3d.hue} onChange={e => handleControlChange('scatter3d', 'hue', e.target.value)} options={categoricalCols} />
                        </>;
                    default: return <div className="text-gray-500">No controls for this chart.</div>;
                }
            };

            return (
                <div className="flex h-screen bg-gray-100 font-sans">
                    {/* Sidebar */}
                    <aside className="w-64 bg-sidebar text-text-sidebar p-4 flex flex-col flex-shrink-0">
                        <h1 className="text-2xl font-bold text-white mb-8">Chart Studio</h1>
                        <nav className="flex-grow">
                            {Array.from(groupedCharts.keys()).map(family => (
                                <div key={family} className="mb-4">
                                    <h2 className="text-sm font-semibold text-gray-400 uppercase tracking-wider mb-2 px-3">{family}</h2>
                                    <ul>
                                        {groupedCharts.get(family).map(chart => (
                                            <li key={chart.name}>
                                                <button
                                                    onClick={() => setActiveChart(chart.name)}
                                                    className={`w-full text-left px-3 py-2 rounded-md text-sm font-medium transition-colors ${
                                                        activeChart === chart.name
                                                            ? 'bg-accent-primary text-white'
                                                            : 'hover:bg-slate-700 hover:text-white'
                                                    }`}
                                                >
                                                    {chart.name}
                                                </button>
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            ))}
                        </nav>
                    </aside>

                    {/* Main Content */}
                    <main className="flex-1 flex flex-col p-6 overflow-hidden">
                        <div className="bg-white p-4 rounded-lg shadow-sm mb-6 flex-shrink-0">
                            <h2 className="text-xl font-bold text-gray-800 mb-3">{activeChart} Controls</h2>
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                {renderControls()}
                            </div>
                        </div>
                        <div className="flex-grow bg-white p-4 rounded-lg shadow-sm flex items-center justify-center overflow-hidden chart-container">
                           {renderChart()}
                        </div>
                    </main>
                </div>
            );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
